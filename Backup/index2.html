<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èŠ‚ç‚¹å›¾å½¢åŒ–ç¼–è¾‘å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #1e1e1e;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        body.light-mode {
            background-color: #f5f5f5;
            color: #333;
        }
        
        .menu-bar {
            background-color: #2d2d30;
            padding: 8px 16px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        body.light-mode .menu-bar {
            background-color: #f0f0f0;
            border-bottom: 1px solid #ccc;
        }
        
        .menu-bar button {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 6px 12px;
            margin-right: 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
        }

        body.light-mode .menu-bar button {
            background-color: #0066cc;
        }
        
        .menu-bar button:hover {
            background-color: #005a9e;
        }

        body.light-mode .menu-bar button:hover {
            background-color: #0052aa;
        }
        
        .menu-group {
            display: flex;
            align-items: center;
        }

        .selection-filter {
            margin: 0 10px;
            padding: 4px 8px;
            background-color: #3c3c3c;
            color: #e0e0e0;
            border: 1px solid #464647;
            border-radius: 3px;
            font-size: 13px;
        }

        body.light-mode .selection-filter {
            background-color: #fff;
            color: #333;
            border: 1px solid #ccc;
        }

        .export-submenu {
            position: relative;
            display: inline-block;
        }

        .export-submenu-content {
            display: none;
            position: absolute;
            background-color: #2d2d30;
            min-width: 120px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
            border-radius: 3px;
        }

        body.light-mode .export-submenu-content {
            background-color: #f0f0f0;
        }

        .export-submenu-content button {
            width: 100%;
            text-align: left;
            margin: 0;
            padding: 8px 12px;
            border-radius: 0;
        }

        .export-submenu:hover .export-submenu-content {
            display: block;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .tool-panel {
            width: 200px;
            background-color: #252526;
            border-right: 1px solid #3e3e42;
            padding: 10px;
        }

        body.light-mode .tool-panel {
            background-color: #e9e9e9;
            border-right: 1px solid #ccc;
        }
        
        .tool-item {
            background-color: #2d2d30;
            border: 1px dashed #4a4a4a;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 4px;
            cursor: grab;
            text-align: center;
            user-select: none;
        }

        body.light-mode .tool-item {
            background-color: #f0f0f0;
            border: 1px dashed #bbb;
            color: #333;
        }
        
        .tool-item:hover {
            background-color: #37373d;
        }

        body.light-mode .tool-item:hover {
            background-color: #d9d9d9;
        }
        
        .workspace {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #1e1e1e;
        }

        body.light-mode .workspace {
            background-color: #f5f5f5;
        }
        
        #editor-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .selection-rectangle {
            position: absolute;
            border: 1px dashed #007acc;
            background-color: rgba(0, 122, 204, 0.1);
            pointer-events: none;
            z-index: 50;
        }
        
        .property-panel {
            width: 300px;
            background-color: #252526;
            border-left: 1px solid #3e3e42;
            padding: 15px;
            overflow-y: auto;
        }

        body.light-mode .property-panel {
            background-color: #e9e9e9;
            border-left: 1px solid #ccc;
        }
        
        .property-section {
            margin-bottom: 20px;
        }
        
        .property-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #cccccc;
            border-bottom: 1px solid #3e3e42;
            padding-bottom: 5px;
        }

        body.light-mode .property-section h3 {
            color: #666;
            border-bottom: 1px solid #ccc;
        }
        
        .form-group {
            margin-bottom: 12px;
        }
        
        .form-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: #969696;
        }

        body.light-mode .form-group label {
            color: #666;
        }
        
        .form-group input, 
        .form-group textarea, 
        .form-group select {
            width: 100%;
            padding: 6px 8px;
            background-color: #3c3c3c;
            border: 1px solid #464647;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 13px;
        }

        body.light-mode .form-group input, 
        body.light-mode .form-group textarea, 
        body.light-mode .form-group select {
            background-color: #fff;
            border: 1px solid #ccc;
            color: #333;
        }
        
        .form-group textarea {
            min-height: 60px;
            resize: vertical;
        }
        
        .condition-item {
            background-color: #2d2d30;
            padding: 8px;
            border-radius: 3px;
            margin-bottom: 8px;
            border-left: 3px solid #007acc;
        }

        body.light-mode .condition-item {
            background-color: #f0f0f0;
            border-left: 3px solid #0066cc;
        }
        
        .condition-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .condition-controls {
            display: flex;
            gap: 5px;
        }
        
        .condition-controls button {
            background: none;
            border: none;
            color: #cccccc;
            cursor: pointer;
            font-size: 12px;
        }

        body.light-mode .condition-controls button {
            color: #666;
        }
        
        .condition-fields {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }
        
        .btn {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        body.light-mode .btn {
            background-color: #0066cc;
        }
        
        .btn:hover {
            background-color: #1177bb;
        }

        body.light-mode .btn:hover {
            background-color: #0052aa;
        }
        
        .btn-danger {
            background-color: #c42b1c;
        }

        body.light-mode .btn-danger {
            background-color: #b32418;
        }
        
        .btn-danger:hover {
            background-color: #da3b2a;
        }

        body.light-mode .btn-danger:hover {
            background-color: #c93222;
        }
        
        .status-bar {
            background-color: #007acc;
            padding: 4px 12px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        body.light-mode .status-bar {
            background-color: #0066cc;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
        }
        
        .zoom-controls button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 2px;
            margin-left: 4px;
            cursor: pointer;
        }
        
        .context-menu {
            position: absolute;
            background-color: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 150px;
        }

        body.light-mode .context-menu {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
        }

        body.light-mode .context-menu-item {
            color: #333;
        }
        
        .context-menu-item:hover {
            background-color: #094771;
        }

        body.light-mode .context-menu-item:hover {
            background-color: #e0e0e0;
        }
        
        .hidden {
            display: none;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
        }
        
        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
    </style>
</head>
<body>
    <!-- é¡¶éƒ¨èœå•æ  -->
    <div class="menu-bar">
        <div class="menu-group">
            <button id="new-project">æ–°å»º</button>
            <button id="import-md">å¯¼å…¥Markdown</button>
            <div class="export-submenu">
                <button id="export-menu">å¯¼å‡º</button>
                <div class="export-submenu-content">
                    <button id="export-md">å¯¼å‡ºMarkdown</button>
                    <button id="export-image">å¯¼å‡ºä¸ºä½å›¾</button>
                </div>
            </div>
            <button id="save-project">ä¿å­˜</button>
            <select id="selection-filter" class="selection-filter">
                <option value="all">é€‰æ‹©æ‰€æœ‰å¯¹è±¡</option>
                <option value="nodes">ä»…é€‰æ‹©èŠ‚ç‚¹</option>
                <option value="connections">ä»…é€‰æ‹©è¿çº¿</option>
            </select>
        </div>
        <div class="menu-group">
            <button id="undo">æ’¤é”€</button>
            <button id="redo">é‡åš</button>
            <button id="toggle-theme">åˆ‡æ¢ä¸»é¢˜</button>
        </div>
    </div>
    
    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content">
        <!-- å·¦ä¾§å·¥å…·æ  -->
        <aside class="tool-panel">
            <div class="tool-item" draggable="true" data-type="node">
                ğŸ“¦ èŠ‚ç‚¹
            </div>
            <div class="tool-item" draggable="true" data-type="connection">
                ğŸ”— è¿çº¿
            </div>
        </aside>
        
        <!-- ä¸­é—´å·¥ä½œåŒº -->
        <section class="workspace">
            <canvas id="editor-canvas"></canvas>
            <div class="selection-rectangle hidden"></div>
        </section>
        
        <!-- å³ä¾§å±æ€§æ  -->
        <aside class="property-panel">
            <div id="node-properties" class="property-section hidden">
                <h3>èŠ‚ç‚¹å±æ€§</h3>
                <div class="form-group">
                    <label for="node-name">èŠ‚ç‚¹åç§°</label>
                    <input type="text" id="node-name">
                </div>
                <div class="form-group">
                    <label for="node-description">èŠ‚ç‚¹æè¿°</label>
                    <textarea id="node-description"></textarea>
                </div>
                
                <!-- æ–°å¢å°ºå¯¸è®¾ç½® -->
                <div class="form-group">
                    <label>å°ºå¯¸è®¾ç½®</label>
                    <div class="checkbox-group">
                        <input type="checkbox" id="node-autosize">
                        <label for="node-autosize">è‡ªé€‚åº”å†…å®¹å°ºå¯¸</label>
                    </div>
                </div>
                
                <div class="form-group dimension-inputs">
                    <div>
                        <label for="node-width">å®½åº¦</label>
                        <input type="number" id="node-width" min="50" max="500" value="120">
                    </div>
                    <div>
                        <label for="node-height">é«˜åº¦</label>
                        <input type="number" id="node-height" min="30" max="300" value="80">
                    </div>
                </div>
                
                <button id="update-node" class="btn">æ›´æ–°èŠ‚ç‚¹</button>
                <button id="delete-node" class="btn btn-danger">åˆ é™¤èŠ‚ç‚¹</button>
            </div>
            
            <div id="connection-properties" class="property-section hidden">
                <h3>è¿çº¿æ¡ä»¶</h3>
                <div id="conditions-list">
                    <!-- æ¡ä»¶é¡¹å°†é€šè¿‡JavaScriptåŠ¨æ€æ·»åŠ  -->
                </div>
                <button id="add-condition" class="btn">æ·»åŠ æ¡ä»¶</button>
                <button id="delete-connection" class="btn btn-danger">åˆ é™¤è¿çº¿</button>
            </div>
            
            <div id="no-selection" class="property-section">
                <h3>æç¤º</h3>
                <p>é€‰æ‹©èŠ‚ç‚¹æˆ–è¿çº¿ä»¥ç¼–è¾‘å…¶å±æ€§</p>
            </div>
        </aside>
    </div>
    
    <!-- åº•éƒ¨çŠ¶æ€æ  -->
    <footer class="status-bar">
        <div class="status-info">å°±ç»ª</div>
        <div class="zoom-controls">
            <button id="zoom-out">-</button>
            <span id="zoom-level">100%</span>
            <button id="zoom-in">+</button>
        </div>
    </footer>
    
    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ï¼Œç”¨äºå¯¼å…¥Markdown -->
    <input type="file" id="file-input" accept=".md" style="display: none;">
    
    <script>
        // ç¦ç”¨é»˜è®¤å³é”®èœå•
        document.addEventListener('DOMContentLoaded', () => {
            document.addEventListener('contextmenu', e => e.preventDefault());
        });

        // å·¥å…·ç±»å’Œè¾…åŠ©å‡½æ•°
        const Utils = {
            // ç”ŸæˆUUID
            generateId: () => crypto.randomUUID(),
            
            // å¤åˆ¶å¯¹è±¡
            deepClone: (obj) => {
                if (obj === null || typeof obj !== 'object') return obj;
                
                if (obj instanceof Array) {
                    return obj.map(item => Utils.deepClone(item));
                }
                
                const clone = {};
                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        clone[key] = Utils.deepClone(obj[key]);
                    }
                }
                return clone;
            },
            
            // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨çŸ©å½¢å†…
            isPointInRect: (x, y, rect) => {
                return x >= rect.x && x <= rect.x + rect.width && 
                       y >= rect.y && y <= rect.y + rect.height;
            },
            
            // æ£€æŸ¥çŸ©å½¢æ˜¯å¦é‡å 
            doRectsOverlap: (rect1, rect2) => {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
        };

        // å†å²è®°å½•é¡¹ç±»
        class HistoryItem {
            constructor(type, data) {
                this.type = type; // 'add', 'delete', 'modify'
                this.data = data;
            }
        }

        // èŠ‚ç‚¹ç±»
        class Node {
            constructor(name, x, y) {
                this.id = Utils.generateId();
                this.type = 'node';
                this.name = name || 'æ–°èŠ‚ç‚¹';
                this.description = '';
                this.x = x;
                this.y = y;
                
                // å°ºå¯¸å±æ€§
                this.width = 120;
                this.height = 80;
                this.autoSize = false; // æ˜¯å¦è‡ªé€‚åº”å°ºå¯¸
                this.minWidth = 80;    // æœ€å°å®½åº¦
                this.minHeight = 60;   // æœ€å°é«˜åº¦
                this.padding = 20;     // å†…è¾¹è·
            }
            
            // è®¡ç®—è‡ªé€‚åº”å°ºå¯¸
            calculateAutoSize(ctx) {
                if (!this.autoSize) return;
                
                // æµ‹é‡åç§°æ–‡æœ¬å®½åº¦
                ctx.font = '14px Arial';
                const nameMetrics = ctx.measureText(this.name);
                const nameWidth = nameMetrics.width + this.padding * 2;
                
                // æµ‹é‡æè¿°æ–‡æœ¬å®½åº¦
                let descWidth = 0;
                if (this.description) {
                    ctx.font = '10px Arial';
                    const desc = this.description.length > 30 ? 
                        this.description.substring(0, 30) + '...' : this.description;
                    descWidth = ctx.measureText(desc).width + this.padding * 2;
                }
                
                // è®¡ç®—æœ€ç»ˆå°ºå¯¸
                this.width = Math.max(this.minWidth, nameWidth, descWidth);
                this.height = this.minHeight + (this.description ? 25 : 0);
            }

            // å¤åˆ¶èŠ‚ç‚¹
            clone() {
                const clone = new Node(this.name, this.x, this.y);
                clone.id = this.id;
                clone.description = this.description;
                clone.width = this.width;
                clone.height = this.height;
                clone.autoSize = this.autoSize;
                clone.minWidth = this.minWidth;
                clone.minHeight = this.minHeight;
                clone.padding = this.padding;
                return clone;
            }
        }
        
        // æ¡ä»¶ç±»
        class Condition {
            constructor(type = 'int', key = '', operator = '>', value = '') {
                this.type = type;
                this.key = key;
                this.operator = operator;
                this.value = value;
            }

            clone() {
                return new Condition(this.type, this.key, this.operator, this.value);
            }
        }
        
        // è¿æ¥ç±»
        class Connection {
            constructor(sourceNodeId, targetNodeId) {
                this.id = Utils.generateId();
                this.type = 'connection';
                this.sourceNodeId = sourceNodeId;
                this.targetNodeId = targetNodeId;
                this.conditions = [];
            }

            clone() {
                const clone = new Connection(this.sourceNodeId, this.targetNodeId);
                clone.id = this.id;
                clone.conditions = this.conditions.map(cond => cond.clone());
                return clone;
            }
        }
        
        // ç¼–è¾‘å™¨ä¸»ç±»
        class NodeGraphEditor {
            constructor(canvasId) {
                // è·å–DOMå…ƒç´ 
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.selectionRectangle = document.querySelector('.selection-rectangle');
                this.zoomLevelDisplay = document.getElementById('zoom-level');
                
                // ç¼–è¾‘å™¨çŠ¶æ€
                this.nodes = [];
                this.connections = [];
                this.selectedElements = []; // æ”¯æŒå¤šé€‰
                this.draggingElement = null;
                this.draggingOffset = { x: 0, y: 0 };
                this.creatingConnection = null;
                this.selectionFilter = 'all'; // é€‰æ‹©ç­›é€‰å™¨ï¼š'all', 'nodes', 'connections'
                
                // æ¡†é€‰ç›¸å…³
                this.isSelecting = false;
                this.selectionStart = { x: 0, y: 0 };
                this.selectionCurrent = { x: 0, y: 0 };
                
                // è§†å›¾çŠ¶æ€
                this.zoom = 1.0;
                this.pan = { x: 0, y: 0 };
                this.isPanning = false;
                this.panStart = { x: 0, y: 0 };
                
                // å†å²è®°å½•
                this.history = [];
                this.historyIndex = -1;
                this.historyLimit = 50; // æœ€å¤šä¿å­˜50æ¡å†å²è®°å½•
                
                // æ€§èƒ½ä¼˜åŒ–
                this.animationId = null;
                this.lastRenderTime = 0;
                this.renderDelay = 16; // ~60FPS
                
                // åˆå§‹åŒ–
                this.init();
            }
            
            // åˆå§‹åŒ–ç¼–è¾‘å™¨
            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupUIListeners();
                this.scheduleRender();
            }
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            setupCanvas() {
                const resizeCanvas = () => {
                    const container = this.canvas.parentElement;
                    this.canvas.width = container.clientWidth;
                    this.canvas.height = container.clientHeight;
                    this.scheduleRender();
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }
            
            // å±å¹•åæ ‡è½¬ä¸–ç•Œåæ ‡
            screenToWorld(x, y) {
                return {
                    x: (x - this.pan.x) / this.zoom,
                    y: (y - this.pan.y) / this.zoom
                };
            }
            
            // ä¸–ç•Œåæ ‡è½¬å±å¹•åæ ‡
            worldToScreen(x, y) {
                return {
                    x: x * this.zoom + this.pan.x,
                    y: y * this.zoom + this.pan.y
                };
            }
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', e => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', e => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', e => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', e => this.handleWheel(e));
                
                // æ‹–æ”¾äº‹ä»¶
                this.canvas.addEventListener('dragover', e => e.preventDefault());
                this.canvas.addEventListener('drop', e => this.handleDrop(e));

                // é¼ æ ‡ç¦»å¼€äº‹ä»¶
                this.canvas.addEventListener('mouseleave', e => this.handleMouseLeave(e));
            }
            
            // è®¾ç½®UIå…ƒç´ ç›‘å¬å™¨
            setupUIListeners() {
                // èœå•æŒ‰é’®
                document.getElementById('new-project').addEventListener('click', () => this.newProject());
                document.getElementById('import-md').addEventListener('click', () => 
                    document.getElementById('file-input').click());
                document.getElementById('export-md').addEventListener('click', () => this.exportMarkdown());
                document.getElementById('export-image').addEventListener('click', () => this.exportAsImage());
                document.getElementById('save-project').addEventListener('click', () => this.saveProject());
                document.getElementById('undo').addEventListener('click', () => this.undo());
                document.getElementById('redo').addEventListener('click', () => this.redo());
                document.getElementById('toggle-theme').addEventListener('click', () => this.toggleTheme());
                
                // é€‰æ‹©ç­›é€‰å™¨
                document.getElementById('selection-filter').addEventListener('change', e => {
                    this.selectionFilter = e.target.value;
                    this.filterSelectedElements();
                    this.updatePropertyPanel();
                    this.scheduleRender();
                });
                
                // ç¼©æ”¾æ§åˆ¶
                document.getElementById('zoom-in').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoom-out').addEventListener('click', () => this.zoomOut());
                
                // å±æ€§é¢æ¿
                document.getElementById('update-node').addEventListener('click', () => this.updateSelectedNode());
                document.getElementById('delete-node').addEventListener('click', () => this.deleteSelectedNodes());
                document.getElementById('add-condition').addEventListener('click', () => this.addCondition());
                document.getElementById('delete-connection').addEventListener('click', () => this.deleteSelectedConnections());
                
                // è‡ªé€‚åº”å°ºå¯¸åˆ‡æ¢
                document.getElementById('node-autosize').addEventListener('change', e => {
                    this.toggleAutoSize(e.target.checked);
                });
                
                // æ–‡ä»¶è¾“å…¥
                document.getElementById('file-input').addEventListener('change', e => this.handleFileSelect(e));
                
                // å·¥å…·æ æ‹–æ‹½
                document.querySelectorAll('.tool-item').forEach(item => {
                    item.addEventListener('dragstart', e => {
                        e.dataTransfer.setData('text/plain', item.dataset.type);
                    });
                });
            }
            
            // è¿‡æ»¤é€‰ä¸­çš„å…ƒç´ 
            filterSelectedElements() {
                this.selectedElements = this.selectedElements.filter(el => {
                    if (this.selectionFilter === 'all') return true;
                    if (this.selectionFilter === 'nodes' && el.type === 'node') return true;
                    if (this.selectionFilter === 'connections' && el.type === 'connection') return true;
                    return false;
                });
            }
            
            // æ·»åŠ å†å²è®°å½•
            addHistory(type, data) {
                // å¦‚æœå½“å‰ä¸åœ¨å†å²è®°å½•æœ«å°¾ï¼Œæ¸…é™¤åé¢çš„è®°å½•
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                
                // æ·»åŠ æ–°è®°å½•
                this.history.push(new HistoryItem(type, data));
                this.historyIndex++;
                
                // å¦‚æœè¶…å‡ºé™åˆ¶ï¼Œç§»é™¤æœ€æ—©çš„è®°å½•
                if (this.history.length > this.historyLimit) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }
            
            // æ’¤é”€æ“ä½œ
            undo() {
                if (this.historyIndex < 0) return;
                
                const item = this.history[this.historyIndex];
                this.historyIndex--;
                
                switch (item.type) {
                    case 'add-node':
                        this.removeNode(item.data.id);
                        break;
                        
                    case 'add-connection':
                        this.removeConnection(item.data.id);
                        break;
                        
                    case 'delete-nodes':
                        this.nodes.push(...item.data.nodes);
                        this.connections.push(...item.data.connections);
                        break;
                        
                    case 'delete-connections':
                        this.connections.push(...item.data);
                        break;
                        
                    case 'modify-node':
                        const nodeToRestore = this.nodes.find(n => n.id === item.data.id);
                        if (nodeToRestore) {
                            Object.assign(nodeToRestore, item.data.oldValue);
                        }
                        break;
                }
                
                this.selectedElements = [];
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // é‡åšæ“ä½œ
            redo() {
                if (this.historyIndex >= this.history.length - 1) return;
                
                this.historyIndex++;
                const item = this.history[this.historyIndex];
                
                switch (item.type) {
                    case 'add-node':
                        this.nodes.push(item.data);
                        break;
                        
                    case 'add-connection':
                        this.connections.push(item.data);
                        break;
                        
                    case 'delete-nodes':
                        const nodeIds = item.data.nodes.map(n => n.id);
                        this.nodes = this.nodes.filter(n => !nodeIds.includes(n.id));
                        this.connections = this.connections.filter(conn => 
                            !nodeIds.includes(conn.sourceNodeId) && !nodeIds.includes(conn.targetNodeId)
                        );
                        break;
                        
                    case 'delete-connections':
                        const connIds = item.data.map(c => c.id);
                        this.connections = this.connections.filter(c => !connIds.includes(c.id));
                        break;
                        
                    case 'modify-node':
                        const nodeToModify = this.nodes.find(n => n.id === item.data.id);
                        if (nodeToModify) {
                            Object.assign(nodeToModify, item.data.newValue);
                        }
                        break;
                }
                
                this.selectedElements = [];
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // åˆ‡æ¢ä¸»é¢˜
            toggleTheme() {
                document.body.classList.toggle('light-mode');
                this.scheduleRender();
            }
            
            // ç¼©æ”¾æ§åˆ¶
            zoomIn() {
                this.zoom = Math.min(this.zoom * 1.2, 5.0);
                this.updateZoomDisplay();
                this.scheduleRender();
            }
            
            zoomOut() {
                this.zoom = Math.max(this.zoom / 1.2, 0.1);
                this.updateZoomDisplay();
                this.scheduleRender();
            }
            
            updateZoomDisplay() {
                this.zoomLevelDisplay.textContent = `${Math.round(this.zoom * 100)}%`;
            }
            
            // å¤„ç†é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                // å³é”®èœå•å¤„ç†
                if (e.button === 2) {
                    this.handleRightClick(worldPos, x, y);
                    return;
                }
                
                // ä¸­é”®å¹³ç§»
                if (e.button === 1) {
                    this.startPanning(x, y);
                    return;
                }
                
                // å·¦é”®å¤„ç†
                if (e.button === 0) {
                    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†èŠ‚ç‚¹
                    const clickedNode = this.nodes.find(node => 
                        Utils.isPointInRect(worldPos.x, worldPos.y, {
                            x: node.x,
                            y: node.y,
                            width: node.width,
                            height: node.height
                        })
                    );
                    
                    if (clickedNode) {
                        this.handleNodeClick(clickedNode, worldPos, e);
                        return;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è¿çº¿
                    const clickedConnection = this.getConnectionAtPosition(worldPos);
                    if (clickedConnection) {
                        this.handleConnectionClick(clickedConnection, e);
                        return;
                    }
                    
                    // å¦‚æœæ²¡æœ‰ç‚¹å‡»ä»»ä½•å…ƒç´ ï¼Œå¼€å§‹æ¡†é€‰æˆ–å¹³ç§»
                    if (e.ctrlKey || e.metaKey) {
                        this.startSelection(x, y);
                    } else {
                        this.startPanning(x, y);
                        this.deselectAll();
                    }
                }
            }
            
            // å¼€å§‹å¹³ç§»
            startPanning(x, y) {
                this.isPanning = true;
                this.panStart.x = x;
                this.panStart.y = y;
                this.canvas.style.cursor = 'grabbing';
            }
            
            // å¼€å§‹æ¡†é€‰
            startSelection(x, y) {
                this.isSelecting = true;
                this.selectionStart.x = x;
                this.selectionStart.y = y;
                this.selectionCurrent.x = x;
                this.selectionCurrent.y = y;
                
                // æ˜¾ç¤ºé€‰æ‹©æ¡†
                this.selectionRectangle.style.left = x + 'px';
                this.selectionRectangle.style.top = y + 'px';
                this.selectionRectangle.style.width = '0px';
                this.selectionRectangle.style.height = '0px';
                this.selectionRectangle.classList.remove('hidden');
                
                // æ·»åŠ å…¨å±€äº‹ä»¶ç›‘å¬
                document.addEventListener('mousemove', this.handleGlobalMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleGlobalMouseUp.bind(this));
            }
            
            // å¤„ç†èŠ‚ç‚¹ç‚¹å‡»
            handleNodeClick(node, worldPos, e) {
                // å¤„ç†è¿æ¥åˆ›å»º
                if (this.creatingConnection) {
                    this.finishConnectionCreation(node.id);
                    return;
                }
                
                // é€‰æ‹©é€»è¾‘
                if (!e.ctrlKey && !e.metaKey) {
                    this.deselectAll();
                }
                
                // åˆ‡æ¢èŠ‚ç‚¹é€‰æ‹©çŠ¶æ€
                const index = this.selectedElements.findIndex(el => el.id === node.id);
                if (index === -1) {
                    this.selectedElements.push(node);
                } else {
                    this.selectedElements.splice(index, 1);
                }
                
                // å‡†å¤‡æ‹–åŠ¨
                this.draggingElement = node;
                this.draggingOffset.x = worldPos.x - node.x;
                this.draggingOffset.y = worldPos.y - node.y;
                
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // å¤„ç†è¿çº¿ç‚¹å‡»
            handleConnectionClick(connection, e) {
                if (!e.ctrlKey && !e.metaKey) {
                    this.deselectAll();
                }
                
                // åˆ‡æ¢è¿çº¿é€‰æ‹©çŠ¶æ€
                const index = this.selectedElements.findIndex(el => el.id === connection.id);
                if (index === -1) {
                    this.selectedElements.push(connection);
                } else {
                    this.selectedElements.splice(index, 1);
                }
                
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // å¤„ç†é¼ æ ‡ç§»åŠ¨äº‹ä»¶
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                // å¹³ç§»å¤„ç†
                if (this.isPanning) {
                    this.pan.x += x - this.panStart.x;
                    this.pan.y += y - this.panStart.y;
                    this.panStart.x = x;
                    this.panStart.y = y;
                    this.scheduleRender();
                    return;
                }
                
                // æ‹–åŠ¨èŠ‚ç‚¹å¤„ç†
                if (this.draggingElement && this.draggingElement.type === 'node') {
                    this.draggingElement.x = worldPos.x - this.draggingOffset.x;
                    this.draggingElement.y = worldPos.y - this.draggingOffset.y;
                    this.scheduleRender();
                    return;
                }
                
                // æ­£åœ¨åˆ›å»ºè¿çº¿
                if (this.creatingConnection) {
                    this.scheduleRender();
                }
            }
            
            // å¤„ç†é¼ æ ‡é‡Šæ”¾äº‹ä»¶
            handleMouseUp(e) {
                // ç»“æŸå¹³ç§»
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvas.style.cursor = 'default';
                    return;
                }
                
                // ç»“æŸæ‹–åŠ¨èŠ‚ç‚¹
                if (this.draggingElement && this.draggingElement.type === 'node') {
                    // å¦‚æœåªé€‰æ‹©äº†ä¸€ä¸ªèŠ‚ç‚¹ä¸”ä½ç½®å‘ç”Ÿäº†å˜åŒ–ï¼Œè®°å½•å†å²
                    if (this.selectedElements.length === 1) {
                        const node = this.selectedElements[0];
                        this.addHistory('modify-node', {
                            id: node.id,
                            oldValue: node.clone(),
                            newValue: Utils.deepClone(node)
                        });
                    }
                    
                    this.draggingElement = null;
                    return;
                }
            }
            
            // å¤„ç†å…¨å±€é¼ æ ‡ç§»åŠ¨ï¼ˆæ¡†é€‰ï¼‰
            handleGlobalMouseMove(e) {
                if (!this.isSelecting) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // æ›´æ–°é€‰æ‹©æ¡†ä½ç½®å’Œå¤§å°
                const left = Math.min(x, this.selectionStart.x);
                const top = Math.min(y, this.selectionStart.y);
                const width = Math.abs(x - this.selectionStart.x);
                const height = Math.abs(y - this.selectionStart.y);
                
                this.selectionCurrent.x = x;
                this.selectionCurrent.y = y;
                this.selectionRectangle.style.left = left + 'px';
                this.selectionRectangle.style.top = top + 'px';
                this.selectionRectangle.style.width = width + 'px';
                this.selectionRectangle.style.height = height + 'px';
            }
            
            // å¤„ç†å…¨å±€é¼ æ ‡é‡Šæ”¾ï¼ˆæ¡†é€‰ç»“æŸï¼‰
            handleGlobalMouseUp(e) {
                if (!this.isSelecting) return;
                
                // ç§»é™¤å…¨å±€äº‹ä»¶ç›‘å¬
                document.removeEventListener('mousemove', this.handleGlobalMouseMove.bind(this));
                document.removeEventListener('mouseup', this.handleGlobalMouseUp.bind(this));
                
                // å¤„ç†æ¡†é€‰å®Œæˆé€»è¾‘
                this.isSelecting = false;
                this.selectionRectangle.classList.add('hidden');
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // è®¡ç®—é€‰æ‹©æ¡†çš„ä¸–ç•Œåæ ‡
                const start = this.screenToWorld(this.selectionStart.x, this.selectionStart.y);
                const end = this.screenToWorld(x, y);
                
                const selectionMinX = Math.min(start.x, end.x);
                const selectionMinY = Math.min(start.y, end.y);
                const selectionMaxX = Math.max(start.x, end.x);
                const selectionMaxY = Math.max(start.y, end.y);
                
                // å¤„ç†é€‰æ‹©
                this.processSelection(selectionMinX, selectionMinY, selectionMaxX, selectionMaxY);
                
                this.draggingElement = null;
                this.isPanning = false;
                this.scheduleRender();
            }
            
            // å¤„ç†é¼ æ ‡ç¦»å¼€äº‹ä»¶
            handleMouseLeave(e) {
                // æ¡†é€‰è¿‡ç¨‹ä¸­é¼ æ ‡ç¦»å¼€ç”»å¸ƒæ—¶ä¸ç»“æŸæ¡†é€‰
                if (this.isSelecting) return;
                
                // ç»“æŸæ‹–åŠ¨å’Œå¹³ç§»
                this.draggingElement = null;
                this.isPanning = false;
                this.canvas.style.cursor = 'default';
            }
            
            // å¤„ç†æ»šè½®äº‹ä»¶ï¼ˆç¼©æ”¾ï¼‰
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // ç¼©æ”¾å‰çš„é¼ æ ‡ä¸–ç•Œåæ ‡
                const mouseWorldX = (mouseX - this.pan.x) / this.zoom;
                const mouseWorldY = (mouseY - this.pan.y) / this.zoom;
                
                // åº”ç”¨ç¼©æ”¾
                if (e.deltaY < 0) {
                    this.zoom = Math.min(this.zoom * 1.1, 5.0);
                } else {
                    this.zoom = Math.max(this.zoom / 1.1, 0.1);
                }
                
                // è°ƒæ•´å¹³ç§»ï¼Œä½¿é¼ æ ‡æŒ‡å‘çš„ä¸–ç•Œåæ ‡ä¿æŒä¸å˜
                this.pan.x = mouseX - mouseWorldX * this.zoom;
                this.pan.y = mouseY - mouseWorldY * this.zoom;
                
                this.updateZoomDisplay();
                this.scheduleRender();
            }
            
            // å¤„ç†æ‹–æ”¾äº‹ä»¶
            handleDrop(e) {
                e.preventDefault();
                const type = e.dataTransfer.getData('text/plain');
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                if (type === 'node') {
                    this.addNode(new Node('æ–°èŠ‚ç‚¹', worldPos.x, worldPos.y));
                } else if (type === 'connection') {
                    // å¼€å§‹åˆ›å»ºè¿çº¿
                    const nodeUnderCursor = this.nodes.find(node => 
                        Utils.isPointInRect(worldPos.x, worldPos.y, {
                            x: node.x,
                            y: node.y,
                            width: node.width,
                            height: node.height
                        })
                    );
                    
                    if (nodeUnderCursor) {
                        this.startConnectionCreation(nodeUnderCursor.id);
                    }
                }
            }
            
            // å¼€å§‹åˆ›å»ºè¿çº¿
            startConnectionCreation(sourceNodeId) {
                this.creatingConnection = {
                    sourceNodeId: sourceNodeId
                };
                this.scheduleRender();
            }
            
            // å®Œæˆè¿çº¿åˆ›å»º
            finishConnectionCreation(targetNodeId) {
                if (this.creatingConnection && 
                    this.creatingConnection.sourceNodeId !== targetNodeId) {
                    
                    const newConnection = new Connection(
                        this.creatingConnection.sourceNodeId,
                        targetNodeId
                    );
                    
                    this.addConnection(newConnection);
                }
                
                this.creatingConnection = null;
                this.scheduleRender();
            }
            
            // å¤„ç†å³é”®ç‚¹å‡»
            handleRightClick(worldPos, screenX, screenY) {
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†èŠ‚ç‚¹
                const clickedNode = this.nodes.find(node => 
                    Utils.isPointInRect(worldPos.x, worldPos.y, {
                        x: node.x,
                        y: node.y,
                        width: node.width,
                        height: node.height
                    })
                );
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†è¿çº¿
                const clickedConnection = this.getConnectionAtPosition(worldPos);
                
                // æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
                if (clickedNode || clickedConnection) {
                    this.showContextMenu(screenX, screenY, clickedNode || clickedConnection);
                }
            }
            
            // æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
            showContextMenu(x, y, element) {
                // æ¸…é™¤ç°æœ‰èœå•
                this.removeContextMenu();
                
                // åˆ›å»ºæ–°èœå•
                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                document.body.appendChild(menu);
                
                // æ·»åŠ èœå•é¡¹
                if (element.type === 'node') {
                    const deleteItem = document.createElement('div');
                    deleteItem.className = 'context-menu-item';
                    deleteItem.textContent = 'åˆ é™¤èŠ‚ç‚¹';
                    deleteItem.addEventListener('click', () => {
                        this.selectedElements = [element];
                        this.deleteSelectedNodes();
                        this.removeContextMenu();
                    });
                    menu.appendChild(deleteItem);
                    
                    const connectItem = document.createElement('div');
                    connectItem.className = 'context-menu-item';
                    connectItem.textContent = 'åˆ›å»ºè¿çº¿';
                    connectItem.addEventListener('click', () => {
                        this.startConnectionCreation(element.id);
                        this.removeContextMenu();
                    });
                    menu.appendChild(connectItem);
                } else if (element.type === 'connection') {
                    const deleteItem = document.createElement('div');
                    deleteItem.className = 'context-menu-item';
                    deleteItem.textContent = 'åˆ é™¤è¿çº¿';
                    deleteItem.addEventListener('click', () => {
                        this.selectedElements = [element];
                        this.deleteSelectedConnections();
                        this.removeContextMenu();
                    });
                    menu.appendChild(deleteItem);
                }
                
                // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
                const closeMenu = () => {
                    this.removeContextMenu();
                    document.removeEventListener('click', closeMenu);
                };
                
                setTimeout(() => {
                    document.addEventListener('click', closeMenu);
                }, 100);
            }
            
            // ç§»é™¤ä¸Šä¸‹æ–‡èœå•
            removeContextMenu() {
                const existingMenu = document.querySelector('.context-menu');
                if (existingMenu) {
                    existingMenu.remove();
                }
            }
            
            // è·å–æŒ‡å®šä½ç½®çš„è¿çº¿
            getConnectionAtPosition(pos) {
                for (const connection of this.connections) {
                    const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                    const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                    
                    if (!sourceNode || !targetNode) continue;
                    
                    // è®¡ç®—è¿çº¿çš„èµ·ç‚¹å’Œç»ˆç‚¹
                    const startX = sourceNode.x + sourceNode.width / 2;
                    const startY = sourceNode.y + sourceNode.height / 2;
                    const endX = targetNode.x + targetNode.width / 2;
                    const endY = targetNode.y + targetNode.height / 2;
                    
                    // ç®€å•çš„è¿çº¿ç‚¹å‡»æ£€æµ‹
                    if (this.isPointNearLine(pos.x, pos.y, startX, startY, endX, endY, 5 / this.zoom)) {
                        return connection;
                    }
                }
                return null;
            }
            
            // æ£€æŸ¥ç‚¹æ˜¯å¦é è¿‘çº¿æ®µ
            isPointNearLine(px, py, x1, y1, x2, y2, tolerance) {
                // çº¿æ®µé•¿åº¦çš„å¹³æ–¹
                const len2 = (x2 - x1) **2 + (y2 - y1)** 2;
                if (len2 === 0) return false; // çº¿æ®µé•¿åº¦ä¸º0
                
                // è®¡ç®—æŠ•å½±æ¯”ä¾‹
                let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / len2;
                t = Math.max(0, Math.min(1, t)); // é™åˆ¶åœ¨[0,1]èŒƒå›´å†…
                
                // è®¡ç®—æŠ•å½±ç‚¹
                const projX = x1 + t * (x2 - x1);
                const projY = y1 + t * (y2 - y1);
                
                // è®¡ç®—ç‚¹åˆ°æŠ•å½±ç‚¹çš„è·ç¦»
                const dx = px - projX;
                const dy = py - projY;
                const dist2 = dx * dx + dy * dy;
                
                return dist2 <= tolerance * tolerance;
            }
            
            // å¤„ç†æ¡†é€‰
            processSelection(minX, minY, maxX, maxY) {
                const selectionRect = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
                
                // æ ¹æ®ç­›é€‰å™¨ç±»å‹é€‰æ‹©å…ƒç´ 
                if (this.selectionFilter === 'all' || this.selectionFilter === 'nodes') {
                    this.nodes.forEach(node => {
                        const nodeRect = {
                            x: node.x,
                            y: node.y,
                            width: node.width,
                            height: node.height
                        };
                        
                        if (Utils.doRectsOverlap(selectionRect, nodeRect)) {
                            this.selectedElements.push(node);
                        }
                    });
                }
                
                if (this.selectionFilter === 'all' || this.selectionFilter === 'connections') {
                    this.connections.forEach(connection => {
                        const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                        const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                        
                        if (sourceNode && targetNode) {
                            // æ£€æŸ¥è¿çº¿çš„ä¸¤ä¸ªç«¯ç‚¹æ˜¯å¦åœ¨é€‰æ‹©æ¡†å†…
                            const startInRect = Utils.isPointInRect(
                                sourceNode.x + sourceNode.width / 2,
                                sourceNode.y + sourceNode.height / 2,
                                selectionRect
                            );
                            
                            const endInRect = Utils.isPointInRect(
                                targetNode.x + targetNode.width / 2,
                                targetNode.y + targetNode.height / 2,
                                selectionRect
                            );
                            
                            if (startInRect && endInRect) {
                                this.selectedElements.push(connection);
                            }
                        }
                    });
                }
                
                // å»é‡
                this.selectedElements = [...new Map(
                    this.selectedElements.map(item => [item.id, item])
                ).values()];
                
                this.updatePropertyPanel();
            }
            
            // å–æ¶ˆæ‰€æœ‰é€‰æ‹©
            deselectAll() {
                this.selectedElements = [];
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // æ·»åŠ èŠ‚ç‚¹
            addNode(node) {
                this.nodes.push(node);
                this.addHistory('add-node', node.clone());
                this.selectedElements = [node];
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // ç§»é™¤èŠ‚ç‚¹
            removeNode(nodeId) {
                // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
                const nodeIndex = this.nodes.findIndex(n => n.id === nodeId);
                if (nodeIndex === -1) return;
                
                const node = this.nodes[nodeIndex];
                
                // æ‰¾åˆ°ç›¸å…³çš„è¿çº¿
                const connectedConnections = this.connections.filter(conn => 
                    conn.sourceNodeId === nodeId || conn.targetNodeId === nodeId
                );
                
                // ç§»é™¤èŠ‚ç‚¹å’Œç›¸å…³è¿çº¿
                this.nodes.splice(nodeIndex, 1);
                connectedConnections.forEach(conn => {
                    const connIndex = this.connections.findIndex(c => c.id === conn.id);
                    if (connIndex !== -1) {
                        this.connections.splice(connIndex, 1);
                    }
                });
                
                // æ›´æ–°é€‰æ‹©
                this.selectedElements = this.selectedElements.filter(
                    el => el.id !== nodeId && !connectedConnections.some(c => c.id === el.id)
                );
                
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // æ·»åŠ è¿çº¿
            addConnection(connection) {
                this.connections.push(connection);
                this.addHistory('add-connection', connection.clone());
                this.selectedElements = [connection];
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // ç§»é™¤è¿çº¿
            removeConnection(connectionId) {
                const connIndex = this.connections.findIndex(c => c.id === connectionId);
                if (connIndex !== -1) {
                    this.connections.splice(connIndex, 1);
                    
                    // æ›´æ–°é€‰æ‹©
                    this.selectedElements = this.selectedElements.filter(el => el.id !== connectionId);
                    
                    this.updatePropertyPanel();
                    this.scheduleRender();
                }
            }
            
            // æ›´æ–°å±æ€§é¢æ¿
            updatePropertyPanel() {
                const nodeProperties = document.getElementById('node-properties');
                const connectionProperties = document.getElementById('connection-properties');
                const noSelection = document.getElementById('no-selection');
                
                // éšè—æ‰€æœ‰é¢æ¿
                nodeProperties.classList.add('hidden');
                connectionProperties.classList.add('hidden');
                noSelection.classList.add('hidden');
                
                // æ˜¾ç¤ºé€‚å½“çš„é¢æ¿
                if (this.selectedElements.length === 1) {
                    const element = this.selectedElements[0];
                    
                    if (element.type === 'node') {
                        this.showNodeProperties(element);
                    } else if (element.type === 'connection') {
                        this.showConnectionProperties(element);
                    }
                } else {
                    noSelection.classList.remove('hidden');
                }
            }
            
            // æ˜¾ç¤ºèŠ‚ç‚¹å±æ€§
            showNodeProperties(node) {
                const nodeProperties = document.getElementById('node-properties');
                const nodeNameInput = document.getElementById('node-name');
                const nodeDescInput = document.getElementById('node-description');
                const nodeWidthInput = document.getElementById('node-width');
                const nodeHeightInput = document.getElementById('node-height');
                const nodeAutosizeInput = document.getElementById('node-autosize');
                
                // å¡«å……è¡¨å•
                nodeNameInput.value = node.name;
                nodeDescInput.value = node.description;
                nodeWidthInput.value = node.width;
                nodeHeightInput.value = node.height;
                nodeAutosizeInput.checked = node.autoSize;
                
                // æ§åˆ¶å°ºå¯¸è¾“å…¥çš„å¯ç”¨æ€§
                nodeWidthInput.disabled = node.autoSize;
                nodeHeightInput.disabled = node.autoSize;
                
                // æ˜¾ç¤ºé¢æ¿
                nodeProperties.classList.remove('hidden');
            }
            
            // æ˜¾ç¤ºè¿çº¿å±æ€§
            showConnectionProperties(connection) {
                const connectionProperties = document.getElementById('connection-properties');
                const conditionsList = document.getElementById('conditions-list');
                
                // æ¸…ç©ºç°æœ‰æ¡ä»¶
                conditionsList.innerHTML = '';
                
                // æ·»åŠ æ‰€æœ‰æ¡ä»¶
                connection.conditions.forEach((condition, index) => {
                    conditionsList.appendChild(this.createConditionElement(condition, index));
                });
                
                // æ˜¾ç¤ºé¢æ¿
                connectionProperties.classList.remove('hidden');
            }
            
            // åˆ›å»ºæ¡ä»¶å…ƒç´ 
            createConditionElement(condition, index) {
                const conditionItem = document.createElement('div');
                conditionItem.className = 'condition-item';
                conditionItem.dataset.index = index;
                
                // æ¡ä»¶å¤´éƒ¨
                const header = document.createElement('div');
                header.className = 'condition-header';
                header.innerHTML = `<span>æ¡ä»¶ ${index + 1}</span>`;
                
                // æ¡ä»¶æ§åˆ¶æŒ‰é’®
                const controls = document.createElement('div');
                controls.className = 'condition-controls';
                
                const upBtn = document.createElement('button');
                upBtn.innerHTML = 'â†‘';
                upBtn.disabled = index === 0;
                upBtn.addEventListener('click', () => this.moveConditionUp(index));
                
                const downBtn = document.createElement('button');
                downBtn.innerHTML = 'â†“';
                downBtn.disabled = index === this.selectedElements[0].conditions.length - 1;
                downBtn.addEventListener('click', () => this.moveConditionDown(index));
                
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = 'âœ•';
                deleteBtn.addEventListener('click', () => this.deleteCondition(index));
                
                controls.appendChild(upBtn);
                controls.appendChild(downBtn);
                controls.appendChild(deleteBtn);
                header.appendChild(controls);
                
                // æ¡ä»¶å­—æ®µ
                const fields = document.createElement('div');
                fields.className = 'condition-fields';
                
                // ç±»å‹é€‰æ‹©
                const typeSelect = document.createElement('select');
                typeSelect.innerHTML = `
                    <option value="int">æ•´æ•°</option>
                    <option value="float">æµ®ç‚¹æ•°</option>
                    <option value="string">å­—ç¬¦ä¸²</option>
                    <option value="boolean">å¸ƒå°”å€¼</option>
                `;
                typeSelect.value = condition.type;
                typeSelect.addEventListener('change', (e) => 
                    this.updateCondition(index, 'type', e.target.value));
                
                // é”®è¾“å…¥
                const keyInput = document.createElement('input');
                keyInput.type = 'text';
                keyInput.placeholder = 'é”®';
                keyInput.value = condition.key;
                keyInput.addEventListener('change', (e) => 
                    this.updateCondition(index, 'key', e.target.value));
                
                // æ“ä½œç¬¦é€‰æ‹©
                const operatorSelect = document.createElement('select');
                operatorSelect.innerHTML = `
                    <option value=">">å¤§äº</option>
                    <option value="<">å°äº</option>
                    <option value="==">ç­‰äº</option>
                    <option value="!=">ä¸ç­‰äº</option>
                    <option value=">=">å¤§äºç­‰äº</option>
                    <option value="<=">å°äºç­‰äº</option>
                `;
                operatorSelect.value = condition.operator;
                operatorSelect.addEventListener('change', (e) => 
                    this.updateCondition(index, 'operator', e.target.value));
                
                // å€¼è¾“å…¥
                const valueInput = document.createElement('input');
                valueInput.type = 'text';
                valueInput.placeholder = 'å€¼';
                valueInput.value = condition.value;
                valueInput.addEventListener('change', (e) => 
                    this.updateCondition(index, 'value', e.target.value));
                
                fields.appendChild(typeSelect);
                fields.appendChild(keyInput);
                fields.appendChild(operatorSelect);
                fields.appendChild(valueInput);
                
                conditionItem.appendChild(header);
                conditionItem.appendChild(fields);
                
                return conditionItem;
            }
            
            // æ›´æ–°èŠ‚ç‚¹å±æ€§
            updateSelectedNode() {
                if (this.selectedElements.length !== 1 || this.selectedElements[0].type !== 'node') {
                    return;
                }
                
                const node = this.selectedElements[0];
                const oldValue = node.clone();
                
                // æ›´æ–°å±æ€§
                node.name = document.getElementById('node-name').value;
                node.description = document.getElementById('node-description').value;
                
                if (!node.autoSize) {
                    node.width = parseInt(document.getElementById('node-width').value) || node.width;
                    node.height = parseInt(document.getElementById('node-height').value) || node.height;
                }
                
                // è®¡ç®—è‡ªé€‚åº”å°ºå¯¸
                node.calculateAutoSize(this.ctx);
                
                // è®°å½•å†å²
                this.addHistory('modify-node', {
                    id: node.id,
                    oldValue: oldValue,
                    newValue: Utils.deepClone(node)
                });
                
                this.scheduleRender();
            }
            
            // åˆ‡æ¢è‡ªé€‚åº”å°ºå¯¸
            toggleAutoSize(enabled) {
                if (this.selectedElements.length !== 1 || this.selectedElements[0].type !== 'node') {
                    return;
                }
                
                const node = this.selectedElements[0];
                const oldValue = node.clone();
                
                node.autoSize = enabled;
                document.getElementById('node-width').disabled = enabled;
                document.getElementById('node-height').disabled = enabled;
                
                // è®¡ç®—è‡ªé€‚åº”å°ºå¯¸
                node.calculateAutoSize(this.ctx);
                
                // æ›´æ–°è¾“å…¥æ¡†
                document.getElementById('node-width').value = node.width;
                document.getElementById('node-height').value = node.height;
                
                // è®°å½•å†å²
                this.addHistory('modify-node', {
                    id: node.id,
                    oldValue: oldValue,
                    newValue: Utils.deepClone(node)
                });
                
                this.scheduleRender();
            }
            
            // åˆ é™¤é€‰ä¸­çš„èŠ‚ç‚¹
            deleteSelectedNodes() {
                const nodesToDelete = this.selectedElements.filter(el => el.type === 'node');
                if (nodesToDelete.length === 0) return;
                
                // æ‰¾åˆ°ç›¸å…³çš„è¿çº¿
                const nodeIds = nodesToDelete.map(n => n.id);
                const connectionsToDelete = this.connections.filter(conn => 
                    nodeIds.includes(conn.sourceNodeId) || nodeIds.includes(conn.targetNodeId)
                );
                
                // è®°å½•å†å²
                this.addHistory('delete-nodes', {
                    nodes: nodesToDelete.map(n => n.clone()),
                    connections: connectionsToDelete.map(c => c.clone())
                });
                
                // åˆ é™¤èŠ‚ç‚¹
                nodesToDelete.forEach(node => this.removeNode(node.id));
                
                this.deselectAll();
            }
            
            // æ·»åŠ æ¡ä»¶
            addCondition() {
                if (this.selectedElements.length !== 1 || this.selectedElements[0].type !== 'connection') {
                    return;
                }
                
                const connection = this.selectedElements[0];
                connection.conditions.push(new Condition());
                this.showConnectionProperties(connection);
            }
            
            // æ›´æ–°æ¡ä»¶
            updateCondition(index, property, value) {
                if (this.selectedElements.length !== 1 || this.selectedElements[0].type !== 'connection') {
                    return;
                }
                
                const connection = this.selectedElements[0];
                if (index >= 0 && index < connection.conditions.length) {
                    connection.conditions[index][property] = value;
                }
            }
            
            // ä¸Šç§»æ¡ä»¶
            moveConditionUp(index) {
                if (index <= 0) return;
                this.swapConditions(index, index - 1);
            }
            
            // ä¸‹ç§»æ¡ä»¶
            moveConditionDown(index) {
                if (this.selectedElements.length !== 1 || this.selectedElements[0].type !== 'connection') {
                    return;
                }
                
                const connection = this.selectedElements[0];
                if (index >= connection.conditions.length - 1) return;
                this.swapConditions(index, index + 1);
            }
            
            // äº¤æ¢æ¡ä»¶ä½ç½®
            swapConditions(i, j) {
                if (this.selectedElements.length !== 1 || this.selectedElements[0].type !== 'connection') {
                    return;
                }
                
                const connection = this.selectedElements[0];
                [connection.conditions[i], connection.conditions[j]] = 
                [connection.conditions[j], connection.conditions[i]];
                
                this.showConnectionProperties(connection);
            }
            
            // åˆ é™¤æ¡ä»¶
            deleteCondition(index) {
                if (this.selectedElements.length !== 1 || this.selectedElements[0].type !== 'connection') {
                    return;
                }
                
                const connection = this.selectedElements[0];
                connection.conditions.splice(index, 1);
                this.showConnectionProperties(connection);
            }
            
            // åˆ é™¤é€‰ä¸­çš„è¿çº¿
            deleteSelectedConnections() {
                const connectionsToDelete = this.selectedElements.filter(el => el.type === 'connection');
                if (connectionsToDelete.length === 0) return;
                
                // è®°å½•å†å²
                this.addHistory('delete-connections', connectionsToDelete.map(c => c.clone()));
                
                // åˆ é™¤è¿çº¿
                connectionsToDelete.forEach(conn => this.removeConnection(conn.id));
                
                this.deselectAll();
            }
            
            // æ–°å»ºé¡¹ç›®
            newProject() {
                if (confirm('ç¡®å®šè¦æ–°å»ºé¡¹ç›®å—ï¼Ÿå½“å‰é¡¹ç›®çš„æ›´æ”¹å°†ä¼šä¸¢å¤±ã€‚')) {
                    this.nodes = [];
                    this.connections = [];
                    this.selectedElements = [];
                    this.history = [];
                    this.historyIndex = -1;
                    this.updatePropertyPanel();
                    this.scheduleRender();
                }
            }
            
            // å¤„ç†æ–‡ä»¶é€‰æ‹©ï¼ˆå¯¼å…¥ï¼‰
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const content = event.target.result;
                        this.importMarkdown(content);
                    } catch (error) {
                        alert('å¯¼å…¥å¤±è´¥: ' + error.message);
                    }
                };
                
                if (file.name.endsWith('.md')) {
                    reader.readAsText(file);
                } else {
                    alert('è¯·é€‰æ‹©Markdownæ–‡ä»¶ (.md)');
                }
                
                // é‡ç½®æ–‡ä»¶è¾“å…¥ï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€ä¸ªæ–‡ä»¶
                e.target.value = '';
            }
            
            // å¯¼å…¥Markdown
            importMarkdown(content) {
                // ç®€å•çš„Markdownè§£æç¤ºä¾‹
                const lines = content.split('\n');
                let currentNode = null;
                let nodesMap = new Map();
                let nodeCounter = 0;
                
                // æ¸…ç©ºç°æœ‰å†…å®¹
                this.nodes = [];
                this.connections = [];
                
                // è§£æMarkdownå¹¶åˆ›å»ºèŠ‚ç‚¹
                lines.forEach(line => {
                    line = line.trim();
                    
                    // æ ‡é¢˜ä½œä¸ºèŠ‚ç‚¹
                    if (line.startsWith('#')) {
                        const level = line.search(/\S|$/);
                        const title = line.substring(level).trim();
                        
                        // åˆ›å»ºæ–°èŠ‚ç‚¹
                        currentNode = new Node(
                            title,
                            100 + (nodeCounter % 5) * 200,
                            100 + Math.floor(nodeCounter / 5) * 150
                        );
                        
                        this.nodes.push(currentNode);
                        nodesMap.set(title, currentNode.id);
                        nodeCounter++;
                    } 
                    // åˆ—è¡¨é¡¹ä½œä¸ºè¿æ¥
                    else if (line.startsWith('-') && currentNode) {
                        const text = line.substring(1).trim();
                        if (nodesMap.has(text)) {
                            this.connections.push(
                                new Connection(currentNode.id, nodesMap.get(text))
                            );
                        }
                    }
                });
                
                this.deselectAll();
                this.scheduleRender();
            }
            
            // å¯¼å‡ºMarkdown
            exportMarkdown() {
                let mdContent = '# èŠ‚ç‚¹å›¾å¯¼å‡º\n\n';
                
                // å¯¼å‡ºèŠ‚ç‚¹
                this.nodes.forEach(node => {
                    mdContent += `## ${node.name}\n`;
                    if (node.description) {
                        mdContent += `${node.description}\n\n`;
                    }
                    
                    // å¯¼å‡ºä»å½“å‰èŠ‚ç‚¹å‡ºå‘çš„è¿æ¥
                    const outgoingConnections = this.connections.filter(
                        conn => conn.sourceNodeId === node.id
                    );
                    
                    if (outgoingConnections.length > 0) {
                        mdContent += 'è¿æ¥åˆ°ï¼š\n';
                        outgoingConnections.forEach(conn => {
                            const targetNode = this.nodes.find(n => n.id === conn.targetNodeId);
                            if (targetNode) {
                                mdContent += `- ${targetNode.name}\n`;
                                
                                // å¯¼å‡ºæ¡ä»¶
                                if (conn.conditions.length > 0) {
                                    conn.conditions.forEach(cond => {
                                        mdContent += `  - æ¡ä»¶: ${cond.key} ${cond.operator} ${cond.value}\n`;
                                    });
                                }
                            }
                        });
                        mdContent += '\n';
                    }
                });
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const blob = new Blob([mdContent], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'èŠ‚ç‚¹å›¾å¯¼å‡º.md';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // å¯¼å‡ºä¸ºå›¾ç‰‡
            exportAsImage() {
                // åˆ›å»ºä¸€ä¸ªä¸´æ—¶canvasç”¨äºå¯¼å‡º
                const exportCanvas = document.createElement('canvas');
                const ctx = exportCanvas.getContext('2d');
                
                // è®¡ç®—æ‰€æœ‰å…ƒç´ çš„è¾¹ç•Œæ¡†
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                // è€ƒè™‘æ‰€æœ‰èŠ‚ç‚¹
                this.nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x + node.width);
                    maxY = Math.max(maxY, node.y + node.height);
                });
                
                // è€ƒè™‘è¿çº¿çš„èµ·ç‚¹å’Œç»ˆç‚¹
                this.connections.forEach(connection => {
                    const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                    const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                    
                    if (sourceNode && targetNode) {
                        const startX = sourceNode.x + sourceNode.width / 2;
                        const startY = sourceNode.y + sourceNode.height / 2;
                        const endX = targetNode.x + targetNode.width / 2;
                        const endY = targetNode.y + targetNode.height / 2;
                        
                        minX = Math.min(minX, startX, endX);
                        minY = Math.min(minY, startY, endY);
                        maxX = Math.max(maxX, startX, endX);
                        maxY = Math.max(maxY, startY, endY);
                    }
                });
                
                // å¦‚æœæ²¡æœ‰å…ƒç´ ï¼Œä½¿ç”¨é»˜è®¤å°ºå¯¸
                if (this.nodes.length === 0 && this.connections.length === 0) {
                    minX = 0;
                    minY = 0;
                    maxX = 800;
                    maxY = 600;
                } else {
                    // æ·»åŠ è¾¹è·
                    const padding = 50;
                    minX -= padding;
                    minY -= padding;
                    maxX += padding;
                    maxY += padding;
                }
                
                // è®¾ç½®å¯¼å‡ºcanvaså°ºå¯¸
                const width = maxX - minX;
                const height = maxY - minY;
                exportCanvas.width = width;
                exportCanvas.height = height;
                
                // ä¿å­˜å½“å‰è§†å›¾çŠ¶æ€
                const originalPan = { ...this.pan };
                const originalZoom = this.zoom;
                const originalSelectedElements = [...this.selectedElements];
                
                // ä¸´æ—¶è°ƒæ•´è§†å›¾ä»¥é€‚åº”æ‰€æœ‰å…ƒç´ 
                this.pan.x = -minX;
                this.pan.y = -minY;
                this.zoom = 1;
                this.selectedElements = [];
                
                // æ¸²æŸ“åˆ°å¯¼å‡ºcanvas
                ctx.fillStyle = document.body.classList.contains('light-mode') ? '#f5f5f5' : '#1e1e1e';
                ctx.fillRect(0, 0, width, height);
                
                // ç»˜åˆ¶ç½‘æ ¼å’Œå…ƒç´ 
                this.drawGrid(ctx, width, height, minX, minY, maxX, maxY);
                this.drawConnections(ctx);
                this.nodes.forEach(node => {
                    node.calculateAutoSize(ctx);
                    this.drawNode(ctx, node);
                });
                
                // æ¢å¤åŸå§‹è§†å›¾çŠ¶æ€
                this.pan = originalPan;
                this.zoom = originalZoom;
                this.selectedElements = originalSelectedElements;
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                exportCanvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'èŠ‚ç‚¹å›¾å¯¼å‡º.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
                
                this.scheduleRender();
            }
            
            // ä¿å­˜é¡¹ç›®
            saveProject() {
                const projectData = {
                    nodes: this.nodes.map(node => ({
                        id: node.id,
                        name: node.name,
                        description: node.description,
                        x: node.x,
                        y: node.y,
                        width: node.width,
                        height: node.height,
                        autoSize: node.autoSize
                    })),
                    connections: this.connections.map(conn => ({
                        id: conn.id,
                        sourceNodeId: conn.sourceNodeId,
                        targetNodeId: conn.targetNodeId,
                        conditions: conn.conditions.map(cond => ({
                            type: cond.type,
                            key: cond.key,
                            operator: cond.operator,
                            value: cond.value
                        }))
                    }))
                };
                
                const json = JSON.stringify(projectData, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'èŠ‚ç‚¹å›¾é¡¹ç›®.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // ç»˜åˆ¶ç½‘æ ¼
            drawGrid(ctx, width = this.canvas.width, height = this.canvas.height, 
                     minX = 0, minY = 0, maxX = width, maxY = height) {
                const gridSize = 20;
                const isLightMode = document.body.classList.contains('light-mode');
                
                ctx.save();
                
                // è®¡ç®—å¯è§ç½‘æ ¼èŒƒå›´
                const startX = Math.floor(minX / gridSize) * gridSize;
                const startY = Math.floor(minY / gridSize) * gridSize;
                const endX = Math.ceil(maxX / gridSize) * gridSize;
                const endY = Math.ceil(maxY / gridSize) * gridSize;
                
                // ç»˜åˆ¶ä¸»ç½‘æ ¼çº¿
                ctx.strokeStyle = isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                
                // æ°´å¹³çº¿
                for (let y = startY; y <= endY; y += gridSize) {
                    const screenY = this.worldToScreen(0, y).y;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(width, screenY);
                    ctx.stroke();
                }
                
                // å‚ç›´çº¿
                for (let x = startX; x <= endX; x += gridSize) {
                    const screenX = this.worldToScreen(x, 0).x;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, height);
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶è¾ƒç²—çš„ç½‘æ ¼çº¿
                ctx.strokeStyle = isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1.5;
                
                // æ°´å¹³çº¿
                for (let y = startY; y <= endY; y += gridSize * 5) {
                    const screenY = this.worldToScreen(0, y).y;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(width, screenY);
                    ctx.stroke();
                }
                
                // å‚ç›´çº¿
                for (let x = startX; x <= endX; x += gridSize * 5) {
                    const screenX = this.worldToScreen(x, 0).x;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, height);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // ç»˜åˆ¶èŠ‚ç‚¹
            drawNode(ctx, node) {
                const screenPos = this.worldToScreen(node.x, node.y);
                const width = node.width * this.zoom;
                const height = node.height * this.zoom;
                
                // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å¯è§
                if (screenPos.x + width < 0 || screenPos.x > this.canvas.width ||
                    screenPos.y + height < 0 || screenPos.y > this.canvas.height) {
                    return;
                }
                
                ctx.save();
                
                // èŠ‚ç‚¹æ˜¯å¦è¢«é€‰ä¸­
                const isSelected = this.selectedElements.some(el => el.id === node.id);
                const isLightMode = document.body.classList.contains('light-mode');
                
                // ç»˜åˆ¶èŠ‚ç‚¹èƒŒæ™¯
                ctx.fillStyle = isSelected 
                    ? '#007acc' 
                    : isLightMode ? '#ffffff' : '#2d2d30';
                
                ctx.strokeStyle = isSelected 
                    ? '#005a9e' 
                    : isLightMode ? '#cccccc' : '#4a4a4a';
                
                ctx.lineWidth = isSelected ? 2 : 1;
                
                ctx.beginPath();
                ctx.roundRect(screenPos.x, screenPos.y, width, height, 4);
                ctx.fill();
                ctx.stroke();
                
                // ç»˜åˆ¶èŠ‚ç‚¹åç§°
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = isSelected ? '#ffffff' : isLightMode ? '#333333' : '#e0e0e0';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.name, screenPos.x + width / 2, screenPos.y + height / 3);
                
                // ç»˜åˆ¶èŠ‚ç‚¹æè¿°
                if (node.description) {
                    ctx.font = '10px Arial';
                    ctx.fillStyle = isSelected ? 'rgba(255, 255, 255, 0.8)' : isLightMode ? '#666666' : '#969696';
                    
                    // æˆªæ–­é•¿æè¿°
                    let displayText = node.description;
                    if (displayText.length > 30) {
                        displayText = displayText.substring(0, 30) + '...';
                    }
                    
                    ctx.fillText(displayText, screenPos.x + width / 2, screenPos.y + height * 2 / 3);
                }
                
                ctx.restore();
            }
            
            // ç»˜åˆ¶è¿çº¿
            drawConnections(ctx) {
                this.connections.forEach(connection => {
                    const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                    const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                    
                    if (!sourceNode || !targetNode) return;
                    
                    // è®¡ç®—è¿çº¿çš„èµ·ç‚¹å’Œç»ˆç‚¹
                    const startX = sourceNode.x + sourceNode.width / 2;
                    const startY = sourceNode.y + sourceNode.height / 2;
                    const endX = targetNode.x + targetNode.width / 2;
                    const endY = targetNode.y + targetNode.height / 2;
                    
                    // è½¬æ¢ä¸ºå±å¹•åæ ‡
                    const screenStart = this.worldToScreen(startX, startY);
                    const screenEnd = this.worldToScreen(endX, endY);
                    
                    // è¿çº¿æ˜¯å¦è¢«é€‰ä¸­
                    const isSelected = this.selectedElements.some(el => el.id === connection.id);
                    const isLightMode = document.body.classList.contains('light-mode');
                    
                    ctx.save();
                    
                    // ç»˜åˆ¶è¿çº¿
                    ctx.strokeStyle = isSelected ? '#007acc' : isLightMode ? '#666666' : '#969696';
                    ctx.lineWidth = isSelected ? 2 : 1.5;
                    ctx.setLineDash([]);
                    
                    ctx.beginPath();
                    ctx.moveTo(screenStart.x, screenStart.y);
                    
                    // è®¡ç®—æ§åˆ¶ç‚¹ï¼Œä½¿è¿çº¿æœ‰ä¸€ä¸ªå¼§åº¦
                    const controlX = (screenStart.x + screenEnd.x) / 2;
                    ctx.quadraticCurveTo(controlX, screenStart.y, screenEnd.x, screenEnd.y);
                    
                    ctx.stroke();
                    
                    // ç»˜åˆ¶ç®­å¤´
                    const arrowSize = 6;
                    const angle = Math.atan2(screenEnd.y - screenStart.y, screenEnd.x - screenStart.x);
                    
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.beginPath();
                    ctx.moveTo(screenEnd.x, screenEnd.y);
                    ctx.lineTo(
                        screenEnd.x - arrowSize * Math.cos(angle - Math.PI / 6),
                        screenEnd.y - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        screenEnd.x - arrowSize * Math.cos(angle + Math.PI / 6),
                        screenEnd.y - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fill();
                    
                    // å¦‚æœæœ‰æ¡ä»¶ï¼Œåœ¨è¿çº¿ä¸­é—´ç»˜åˆ¶ä¸€ä¸ªæ ‡è®°
                    if (connection.conditions.length > 0) {
                        const midX = (screenStart.x + screenEnd.x) / 2;
                        const midY = (screenStart.y + screenEnd.y) / 2 - 10;
                        
                        ctx.fillStyle = isLightMode ? '#ffffff' : '#2d2d30';
                        ctx.strokeStyle = ctx.strokeStyle;
                        ctx.lineWidth = 1;
                        
                        ctx.beginPath();
                        ctx.arc(midX, midY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.font = '8px Arial';
                        ctx.fillStyle = ctx.strokeStyle;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(connection.conditions.length, midX, midY);
                    }
                    
                    ctx.restore();
                });
                
                // ç»˜åˆ¶æ­£åœ¨åˆ›å»ºçš„è¿çº¿
                if (this.creatingConnection) {
                    const sourceNode = this.nodes.find(n => n.id === this.creatingConnection.sourceNodeId);
                    if (sourceNode) {
                        const startX = sourceNode.x + sourceNode.width / 2;
                        const startY = sourceNode.y + sourceNode.height / 2;
                        const screenStart = this.worldToScreen(startX, startY);
                        
                        // è·å–é¼ æ ‡ä½ç½®
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseX = this.lastMouseX - rect.left;
                        const mouseY = this.lastMouseY - rect.top;
                        
                        ctx.save();
                        ctx.strokeStyle = '#007acc';
                        ctx.lineWidth = 1.5;
                        ctx.setLineDash([5, 5]);
                        
                        ctx.beginPath();
                        ctx.moveTo(screenStart.x, screenStart.y);
                        ctx.lineTo(mouseX, mouseY);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
            
            // æ¸²æŸ“å‡½æ•°
            render(timestamp) {
                // é™åˆ¶æ¸²æŸ“é¢‘ç‡
                if (timestamp - this.lastRenderTime < this.renderDelay) {
                    this.scheduleRender();
                    return;
                }
                
                this.lastRenderTime = timestamp;
                
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶ç½‘æ ¼
                this.drawGrid(this.ctx);
                
                // ç»˜åˆ¶è¿çº¿
                this.drawConnections(this.ctx);
                
                // ç»˜åˆ¶èŠ‚ç‚¹
                this.nodes.forEach(node => {
                    node.calculateAutoSize(this.ctx);
                    this.drawNode(this.ctx, node);
                });
                
                // ç»§ç»­æ¸²æŸ“å¾ªç¯
                this.scheduleRender();
            }
            
            // å®‰æ’æ¸²æŸ“
            scheduleRender() {
                if (!this.animationId) {
                    this.animationId = requestAnimationFrame(timestamp => {
                        this.animationId = null;
                        this.render(timestamp);
                    });
                }
            }
        }
        
        // åˆå§‹åŒ–ç¼–è¾‘å™¨
        document.addEventListener('DOMContentLoaded', () => {
            const editor = new NodeGraphEditor('editor-canvas');
        });
    </script>
</body>
</html>