<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èŠ‚ç‚¹å›¾å½¢åŒ–ç¼–è¾‘å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #1e1e1e;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        .menu-bar {
            background-color: #2d2d30;
            padding: 8px 16px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            align-items: center;
        }
        
        .menu-bar button {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 6px 12px;
            margin-right: 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
        }
        
        .menu-bar button:hover {
            background-color: #005a9e;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .tool-panel {
            width: 200px;
            background-color: #252526;
            border-right: 1px solid #3e3e42;
            padding: 10px;
        }
        
        .tool-item {
            background-color: #2d2d30;
            border: 1px dashed #4a4a4a;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 4px;
            cursor: grab;
            text-align: center;
            user-select: none;
        }
        
        .tool-item:hover {
            background-color: #37373d;
        }
        
        .workspace {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #1e1e1e;
        }
        
        #editor-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .property-panel {
            width: 300px;
            background-color: #252526;
            border-left: 1px solid #3e3e42;
            padding: 15px;
            overflow-y: auto;
        }
        
        .property-section {
            margin-bottom: 20px;
        }
        
        .property-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #cccccc;
            border-bottom: 1px solid #3e3e42;
            padding-bottom: 5px;
        }
        
        .form-group {
            margin-bottom: 12px;
        }
        
        .form-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: #969696;
        }
        
        .form-group input, 
        .form-group textarea, 
        .form-group select {
            width: 100%;
            padding: 6px 8px;
            background-color: #3c3c3c;
            border: 1px solid #464647;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 13px;
        }
        
        .form-group textarea {
            min-height: 60px;
            resize: vertical;
        }
        
        .condition-item {
            background-color: #2d2d30;
            padding: 8px;
            border-radius: 3px;
            margin-bottom: 8px;
            border-left: 3px solid #007acc;
        }
        
        .condition-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .condition-controls {
            display: flex;
            gap: 5px;
        }
        
        .condition-controls button {
            background: none;
            border: none;
            color: #cccccc;
            cursor: pointer;
            font-size: 12px;
        }
        
        .condition-fields {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }
        
        .btn {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .btn:hover {
            background-color: #1177bb;
        }
        
        .btn-danger {
            background-color: #c42b1c;
        }
        
        .btn-danger:hover {
            background-color: #da3b2a;
        }
        
        .status-bar {
            background-color: #007acc;
            padding: 4px 12px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
        }
        
        .zoom-controls button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 2px;
            margin-left: 4px;
            cursor: pointer;
        }
        
        .context-menu {
            position: absolute;
            background-color: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 150px;
        }
        
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
        }
        
        .context-menu-item:hover {
            background-color: #094771;
        }
        
        .hidden {
            display: none;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
        }
        
        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
    </style>
</head>
<body>
    <!-- é¡¶éƒ¨èœå•æ  -->
    <div class="menu-bar">
        <button id="new-project">æ–°å»º</button>
        <button id="import-md">å¯¼å…¥Markdown</button>
        <button id="export-md">å¯¼å‡ºMarkdown</button>
        <button id="save-project">ä¿å­˜</button>
    </div>
    
    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content">
        <!-- å·¦ä¾§å·¥å…·æ  -->
        <aside class="tool-panel">
            <div class="tool-item" draggable="true" data-type="node">
                ğŸ“¦ èŠ‚ç‚¹
            </div>
            <div class="tool-item" draggable="true" data-type="connection">
                ğŸ”— è¿çº¿
            </div>
        </aside>
        
        <!-- ä¸­é—´å·¥ä½œåŒº -->
        <section class="workspace">
            <canvas id="editor-canvas"></canvas>
        </section>
        
        <!-- å³ä¾§å±æ€§æ  -->
        <aside class="property-panel">
            <div id="node-properties" class="property-section hidden">
                <h3>èŠ‚ç‚¹å±æ€§</h3>
                <div class="form-group">
                    <label for="node-name">èŠ‚ç‚¹åç§°</label>
                    <input type="text" id="node-name">
                </div>
                <div class="form-group">
                    <label for="node-description">èŠ‚ç‚¹æè¿°</label>
                    <textarea id="node-description"></textarea>
                </div>
                
                <!-- æ–°å¢å°ºå¯¸è®¾ç½® -->
                <div class="form-group">
                    <label>å°ºå¯¸è®¾ç½®</label>
                    <div class="checkbox-group">
                        <input type="checkbox" id="node-autosize">
                        <label for="node-autosize">è‡ªé€‚åº”å†…å®¹å°ºå¯¸</label>
                    </div>
                </div>
                
                <div class="form-group dimension-inputs">
                    <div>
                        <label for="node-width">å®½åº¦</label>
                        <input type="number" id="node-width" min="50" max="500" value="120">
                    </div>
                    <div>
                        <label for="node-height">é«˜åº¦</label>
                        <input type="number" id="node-height" min="30" max="300" value="80">
                    </div>
                </div>
                
                <button id="update-node" class="btn">æ›´æ–°èŠ‚ç‚¹</button>
                <button id="delete-node" class="btn btn-danger">åˆ é™¤èŠ‚ç‚¹</button>
            </div>
            
            <div id="connection-properties" class="property-section hidden">
                <h3>è¿çº¿æ¡ä»¶</h3>
                <div id="conditions-list">
                    <!-- æ¡ä»¶é¡¹å°†é€šè¿‡JavaScriptåŠ¨æ€æ·»åŠ  -->
                </div>
                <button id="add-condition" class="btn">æ·»åŠ æ¡ä»¶</button>
                <button id="delete-connection" class="btn btn-danger">åˆ é™¤è¿çº¿</button>
            </div>
            
            <div id="no-selection" class="property-section">
                <h3>æç¤º</h3>
                <p>é€‰æ‹©èŠ‚ç‚¹æˆ–è¿çº¿ä»¥ç¼–è¾‘å…¶å±æ€§</p>
            </div>
        </aside>
    </div>
    
    <!-- åº•éƒ¨çŠ¶æ€æ  -->
    <footer class="status-bar">
        <div class="status-info">å°±ç»ª</div>
        <div class="zoom-controls">
            <button id="zoom-out">-</button>
            <span id="zoom-level">100%</span>
            <button id="zoom-in">+</button>
        </div>
    </footer>
    
    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ï¼Œç”¨äºå¯¼å…¥Markdown -->
    <input type="file" id="file-input" accept=".md" style="display: none;">
    
    <script>
        // ç¦ç”¨é»˜è®¤å³é”®èœå•
        document.addEventListener('DOMContentLoaded', (event) => {
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
        });

        // èŠ‚ç‚¹ç±»
        class Node {
            constructor(name, x, y) {
                this.id = crypto.randomUUID();
                this.type = 'node';
                this.name = name;
                this.description = '';
                this.x = x;
                this.y = y;
                
                // æ–°å¢å°ºå¯¸å±æ€§
                this.width = 120;
                this.height = 80;
                this.autoSize = false; // æ˜¯å¦è‡ªé€‚åº”å°ºå¯¸
                this.minWidth = 80;    // æœ€å°å®½åº¦
                this.minHeight = 60;   // æœ€å°é«˜åº¦
                this.padding = 20;     // å†…è¾¹è·
            }
            
            // è®¡ç®—è‡ªé€‚åº”å°ºå¯¸
            calculateAutoSize(ctx) {
                if (!this.autoSize) return;
                
                // æµ‹é‡åç§°æ–‡æœ¬å®½åº¦
                ctx.font = '14px Arial';
                const nameMetrics = ctx.measureText(this.name);
                const nameWidth = nameMetrics.width + this.padding * 2;
                
                // æµ‹é‡æè¿°æ–‡æœ¬å®½åº¦
                let descWidth = 0;
                if (this.description) {
                    ctx.font = '10px Arial';
                    const desc = this.description.length > 30 ? 
                        this.description.substring(0, 30) + '...' : this.description;
                    descWidth = ctx.measureText(desc).width + this.padding * 2;
                }
                
                // è®¡ç®—æœ€ç»ˆå°ºå¯¸
                this.width = Math.max(this.minWidth, nameWidth, descWidth);
                this.height = this.minHeight + (this.description ? 25 : 0);
            }
        }
        
        // æ¡ä»¶ç±»
        class Condition {
            constructor(type = 'int', key = '', operator = '>', value = '') {
                this.type = type;
                this.key = key;
                this.operator = operator;
                this.value = value;
            }
        }
        
        // è¿æ¥ç±»
        class Connection {
            constructor(sourceNodeId, targetNodeId) {
                this.id = crypto.randomUUID();
                this.type = 'connection';
                this.sourceNodeId = sourceNodeId;
                this.targetNodeId = targetNodeId;
                this.conditions = [];
            }
        }
        
        // ç¼–è¾‘å™¨ä¸»ç±»
        class NodeGraphEditor {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // ç¼–è¾‘å™¨çŠ¶æ€
                this.nodes = [];
                this.connections = [];
                this.selectedElement = null;
                this.draggingElement = null;
                this.draggingOffset = { x: 0, y: 0 };
                this.creatingConnection = null;
                
                // è§†å›¾çŠ¶æ€
                this.zoom = 1.0;
                this.pan = { x: 0, y: 0 };
                this.isPanning = false;
                this.panStart = { x: 0, y: 0 };
                
                // æ€§èƒ½ä¼˜åŒ–
                this.animationId = null;
                this.lastRenderTime = 0;
                this.renderDelay = 16; // ~60FPS
                
                // åˆå§‹åŒ–
                this.setupCanvas();
                this.setupEventListeners();
                this.setupUIListeners();
                this.scheduleRender();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.scheduleRender();
            }
            
            setupEventListeners() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                
                // é˜»æ­¢é»˜è®¤å³é”®èœå•
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // æ‹–æ”¾äº‹ä»¶
                this.canvas.addEventListener('dragover', (e) => e.preventDefault());
                this.canvas.addEventListener('drop', (e) => this.handleDrop(e));
            }
            
            setupUIListeners() {
                // èœå•æŒ‰é’®
                document.getElementById('new-project').addEventListener('click', () => this.newProject());
                document.getElementById('import-md').addEventListener('click', () => document.getElementById('file-input').click());
                document.getElementById('export-md').addEventListener('click', () => this.exportMarkdown());
                document.getElementById('save-project').addEventListener('click', () => this.saveProject());
                
                // ç¼©æ”¾æ§åˆ¶
                document.getElementById('zoom-in').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoom-out').addEventListener('click', () => this.zoomOut());
                
                // å±æ€§é¢æ¿
                document.getElementById('update-node').addEventListener('click', () => this.updateSelectedNode());
                document.getElementById('delete-node').addEventListener('click', () => this.deleteSelectedNode());
                document.getElementById('add-condition').addEventListener('click', () => this.addCondition());
                document.getElementById('delete-connection').addEventListener('click', () => this.deleteSelectedConnection());
                
                // è‡ªé€‚åº”å°ºå¯¸åˆ‡æ¢
                document.getElementById('node-autosize').addEventListener('change', (e) => {
                    this.toggleAutoSize(e.target.checked);
                });
                
                // æ–‡ä»¶è¾“å…¥
                document.getElementById('file-input').addEventListener('change', (e) => this.handleFileSelect(e));
                
                // å·¥å…·æ æ‹–æ‹½
                document.querySelectorAll('.tool-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', item.dataset.type);
                    });
                });
            }
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šèŠ‚æµæ¸²æŸ“
            scheduleRender() {
                if (this.animationId) return;
                
                this.animationId = requestAnimationFrame((timestamp) => {
                    if (timestamp - this.lastRenderTime > this.renderDelay) {
                        this.render();
                        this.lastRenderTime = timestamp;
                    }
                    this.animationId = null;
                });
            }
            
            // åæ ‡è½¬æ¢
            screenToWorld(x, y) {
                return {
                    x: (x - this.pan.x) / this.zoom,
                    y: (y - this.pan.y) / this.zoom
                };
            }
            
            worldToScreen(x, y) {
                return {
                    x: x * this.zoom + this.pan.x,
                    y: y * this.zoom + this.pan.y
                };
            }
            
            // é¼ æ ‡äº‹ä»¶å¤„ç†
            handleMouseDown(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                // å³é”®å¤„ç†
                if (e.button === 2) {
                    this.showContextMenu(x, y);
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†èŠ‚ç‚¹æˆ–è¿çº¿
                const element = this.getElementAt(worldPos.x, worldPos.y);
                
                if (element) {
                    this.selectedElement = element;
                    this.updatePropertyPanel();
                    
                    if (element.type === 'node') {
                        if (e.ctrlKey) {
                            // å¼€å§‹åˆ›å»ºè¿çº¿
                            this.creatingConnection = {
                                sourceNode: element,
                                x1: element.x + element.width / 2,
                                y1: element.y + element.height / 2,
                                x2: worldPos.x,
                                y2: worldPos.y
                            };
                        } else {
                            // å¼€å§‹æ‹–åŠ¨èŠ‚ç‚¹
                            this.draggingElement = element;
                            this.draggingOffset.x = worldPos.x - element.x;
                            this.draggingOffset.y = worldPos.y - element.y;
                        }
                    }
                } else {
                    this.selectedElement = null;
                    this.updatePropertyPanel();
                    
                    // å¼€å§‹å¹³ç§»è§†å›¾
                    this.isPanning = true;
                    this.panStart.x = x - this.pan.x;
                    this.panStart.y = y - this.pan.y;
                }
                
                this.scheduleRender();
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                // æ›´æ–°çŠ¶æ€æ 
                document.querySelector('.status-info').textContent = 
                    `X: ${Math.round(worldPos.x)}, Y: ${Math.round(worldPos.y)} ç¼©æ”¾: ${Math.round(this.zoom * 100)}%`;
                
                if (this.draggingElement) {
                    // æ‹–åŠ¨èŠ‚ç‚¹
                    this.draggingElement.x = worldPos.x - this.draggingOffset.x;
                    this.draggingElement.y = worldPos.y - this.draggingOffset.y;
                    this.scheduleRender();
                } else if (this.creatingConnection) {
                    // æ›´æ–°è¿çº¿é¢„è§ˆ
                    this.creatingConnection.x2 = worldPos.x;
                    this.creatingConnection.y2 = worldPos.y;
                    this.scheduleRender();
                } else if (this.isPanning) {
                    // å¹³ç§»è§†å›¾
                    this.pan.x = x - this.panStart.x;
                    this.pan.y = y - this.panStart.y;
                    this.scheduleRender();
                }
            }
            
            handleMouseUp(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                if (this.creatingConnection) {
                    // å®Œæˆè¿çº¿åˆ›å»º
                    const targetElement = this.getElementAt(worldPos.x, worldPos.y);
                    
                    if (targetElement && targetElement.type === 'node' && 
                        targetElement !== this.creatingConnection.sourceNode) {
                        // åˆ›å»ºæ–°è¿çº¿
                        const connection = new Connection(
                            this.creatingConnection.sourceNode.id,
                            targetElement.id
                        );
                        this.connections.push(connection);
                        this.selectedElement = connection;
                        this.updatePropertyPanel();
                    }
                    
                    this.creatingConnection = null;
                }
                
                this.draggingElement = null;
                this.isPanning = false;
                this.scheduleRender();
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // æ›´å¹³æ»‘çš„ç¼©æ”¾æ§åˆ¶
                const zoomIntensity = 0.002;
                const wheel = e.deltaY < 0 ? 1 : -1;
                const zoomFactor = 1 + wheel * zoomIntensity * Math.abs(this.zoom);
                
                // åº”ç”¨ç¼©æ”¾
                const newZoom = this.zoom * zoomFactor;
                this.zoom = Math.max(0.1, Math.min(5, newZoom));
                
                // è°ƒæ•´å¹³ç§»ä½¿ç¼©æ”¾å›´ç»•é¼ æ ‡ä½ç½®
                this.pan.x = x - (x - this.pan.x) * (this.zoom / newZoom);
                this.pan.y = y - (y - this.pan.y) * (this.zoom / newZoom);
                
                document.getElementById('zoom-level').textContent = Math.round(this.zoom * 100) + '%';
                this.scheduleRender();
            }
            
            handleDrop(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                const type = e.dataTransfer.getData('text/plain');
                
                if (type === 'node') {
                    // åˆ›å»ºæ–°èŠ‚ç‚¹
                    const node = new Node(`èŠ‚ç‚¹${this.nodes.length + 1}`, worldPos.x, worldPos.y);
                    this.nodes.push(node);
                    this.selectedElement = node;
                    this.updatePropertyPanel();
                    this.scheduleRender();
                }
            }
            
            // å…ƒç´ é€‰æ‹©
            getElementAt(x, y) {
                // å…ˆæ£€æŸ¥è¿çº¿ï¼ˆä»åå¾€å‰ï¼Œå› ä¸ºåé¢çš„è¿çº¿ç»˜åˆ¶åœ¨ä¸Šé¢ï¼‰
                for (let i = this.connections.length - 1; i >= 0; i--) {
                    const connection = this.connections[i];
                    if (this.isPointOnConnection(x, y, connection)) {
                        return connection;
                    }
                }
                
                // æ£€æŸ¥èŠ‚ç‚¹ï¼ˆä»åå¾€å‰ï¼Œå› ä¸ºåé¢çš„èŠ‚ç‚¹ç»˜åˆ¶åœ¨ä¸Šé¢ï¼‰
                for (let i = this.nodes.length - 1; i >= 0; i--) {
                    const node = this.nodes[i];
                    if (this.isPointInNode(x, y, node)) {
                        return node;
                    }
                }
                
                return null;
            }
            
            isPointInNode(x, y, node) {
                return x >= node.x && x <= node.x + node.width && 
                       y >= node.y && y <= node.y + node.height;
            }
            
            isPointOnConnection(x, y, connection) {
                const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                
                if (!sourceNode || !targetNode) return false;
                
                const startX = sourceNode.x + sourceNode.width / 2;
                const startY = sourceNode.y + sourceNode.height / 2;
                const endX = targetNode.x + targetNode.width / 2;
                const endY = targetNode.y + targetNode.height / 2;
                
                const threshold = 5;
                const A = x - startX;
                const B = y - startY;
                const C = endX - startX;
                const D = endY - startY;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }
                
                let xx, yy;
                
                if (param < 0) {
                    xx = startX;
                    yy = startY;
                } else if (param > 1) {
                    xx = endX;
                    yy = endY;
                } else {
                    xx = startX + param * C;
                    yy = startY + param * D;
                }
                
                const dx = x - xx;
                const dy = y - yy;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance <= threshold;
            }
            
            // æ¸²æŸ“
            render() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // æ¸…é™¤ç”»å¸ƒ
                ctx.fillStyle = '#1e1e1e';
                ctx.fillRect(0, 0, width, height);
                
                // åº”ç”¨ç¼©æ”¾å’Œå¹³ç§»
                ctx.save();
                ctx.translate(this.pan.x, this.pan.y);
                ctx.scale(this.zoom, this.zoom);
                
                // ç»˜åˆ¶ç½‘æ ¼ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
                this.drawGrid();
                
                // ç»˜åˆ¶è¿çº¿
                this.connections.forEach(connection => {
                    this.drawConnection(connection, connection === this.selectedElement);
                });
                
                // ç»˜åˆ¶è¿çº¿é¢„è§ˆ
                if (this.creatingConnection) {
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = '#007acc';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const start = this.worldToScreen(
                        this.creatingConnection.x1, 
                        this.creatingConnection.y1
                    );
                    const end = this.worldToScreen(
                        this.creatingConnection.x2, 
                        this.creatingConnection.y2
                    );
                    
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // ç»˜åˆ¶èŠ‚ç‚¹
                this.nodes.forEach(node => {
                    this.drawNode(node, node === this.selectedElement);
                });
                
                ctx.restore();
            }
            
            drawGrid() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // è®¡ç®—å¯è§åŒºåŸŸï¼ˆä¸–ç•Œåæ ‡ï¼‰
                const visibleLeft = -this.pan.x / this.zoom;
                const visibleTop = -this.pan.y / this.zoom;
                const visibleRight = (width - this.pan.x) / this.zoom;
                const visibleBottom = (height - this.pan.y) / this.zoom;
                
                const gridSize = 20;
                
                // åªç»˜åˆ¶å¯è§åŒºåŸŸçš„ç½‘æ ¼
                const startX = Math.floor(visibleLeft / gridSize) * gridSize;
                const endX = Math.ceil(visibleRight / gridSize) * gridSize;
                const startY = Math.floor(visibleTop / gridSize) * gridSize;
                const endY = Math.ceil(visibleBottom / gridSize) * gridSize;
                
                ctx.strokeStyle = '#252525';
                ctx.lineWidth = 1;
                
                // æ‰¹é‡ç»˜åˆ¶å‚ç›´çº¿
                ctx.beginPath();
                for (let x = startX; x <= endX; x += gridSize) {
                    const screenX = x * this.zoom + this.pan.x;
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, height);
                }
                ctx.stroke();
                
                // æ‰¹é‡ç»˜åˆ¶æ°´å¹³çº¿
                ctx.beginPath();
                for (let y = startY; y <= endY; y += gridSize) {
                    const screenY = y * this.zoom + this.pan.y;
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(width, screenY);
                }
                ctx.stroke();
            }
            
            drawNode(node, isSelected) {
                const ctx = this.ctx;
                
                // å¦‚æœå¯ç”¨è‡ªé€‚åº”ï¼Œè®¡ç®—åˆé€‚å°ºå¯¸
                if (node.autoSize) {
                    node.calculateAutoSize(ctx);
                }
                
                // èŠ‚ç‚¹èƒŒæ™¯
                ctx.fillStyle = isSelected ? '#2a7fb6' : '#323233';
                ctx.fillRect(node.x, node.y, node.width, node.height);
                
                // èŠ‚ç‚¹è¾¹æ¡†
                ctx.strokeStyle = isSelected ? '#007acc' : '#464647';
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.strokeRect(node.x, node.y, node.width, node.height);
                
                // èŠ‚ç‚¹æ–‡æœ¬
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // åç§°æ–‡æœ¬
                const nameY = node.y + node.height / 2;
                ctx.fillText(node.name, node.x + node.width / 2, nameY);
                
                // æè¿°æ–‡æœ¬ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (node.description) {
                    ctx.font = '10px Arial';
                    ctx.fillStyle = '#969696';
                    const desc = node.description.length > 30 ? 
                        node.description.substring(0, 30) + '...' : node.description;
                    ctx.fillText(desc, node.x + node.width / 2, nameY + 15);
                }
                
                // æ˜¾ç¤ºå°ºå¯¸ä¿¡æ¯ï¼ˆè°ƒè¯•ç”¨ï¼‰
                if (isSelected) {
                    ctx.font = '8px Arial';
                    ctx.fillStyle = '#888888';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${node.width}Ã—${node.height}`, node.x + 5, node.y + node.height - 5);
                    ctx.textAlign = 'center';
                }
            }
            
            drawConnection(connection, isSelected) {
                const ctx = this.ctx;
                const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                
                if (!sourceNode || !targetNode) return;
                
                const startX = sourceNode.x + sourceNode.width / 2;
                const startY = sourceNode.y + sourceNode.height / 2;
                const endX = targetNode.x + targetNode.width / 2;
                const endY = targetNode.y + targetNode.height / 2;
                
                // è¿çº¿é¢œè‰²
                ctx.strokeStyle = isSelected ? '#007acc' : '#666666';
                ctx.lineWidth = isSelected ? 3 : 2;
                
                // ç»˜åˆ¶è¿çº¿
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // ç»˜åˆ¶ç®­å¤´
                const angle = Math.atan2(endY - startY, endX - startX);
                const arrowLength = 10;
                
                ctx.fillStyle = isSelected ? '#007acc' : '#666666';
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle - Math.PI / 6),
                    endY - arrowLength * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle + Math.PI / 6),
                    endY - arrowLength * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
                
                // ç»˜åˆ¶æ¡ä»¶æ•°é‡æ ‡è®°
                if (connection.conditions.length > 0) {
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;
                    
                    ctx.fillStyle = isSelected ? '#007acc' : '#464647';
                    ctx.beginPath();
                    ctx.arc(midX, midY, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#e0e0e0';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(connection.conditions.length.toString(), midX, midY);
                }
            }
            
            // ä¸Šä¸‹æ–‡èœå•
            showContextMenu(x, y) {
                // ç§»é™¤ç°æœ‰èœå•
                const existingMenu = document.querySelector('.context-menu');
                if (existingMenu) {
                    existingMenu.remove();
                }
                
                // åˆ›å»ºæ–°èœå•
                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                
                const worldPos = this.screenToWorld(x, y);
                const element = this.getElementAt(worldPos.x, worldPos.y);
                
                if (element) {
                    if (element.type === 'node') {
                        menu.innerHTML = `
                            <div class="context-menu-item" data-action="create-connection">åˆ›å»ºè¿çº¿</div>
                            <div class="context-menu-item" data-action="delete-node">åˆ é™¤èŠ‚ç‚¹</div>
                        `;
                    } else if (element.type === 'connection') {
                        menu.innerHTML = `
                            <div class="context-menu-item" data-action="delete-connection">åˆ é™¤è¿çº¿</div>
                        `;
                    }
                } else {
                    menu.innerHTML = `
                        <div class="context-menu-item" data-action="create-node">åˆ›å»ºèŠ‚ç‚¹</div>
                        <div class="context-menu-item" data-action="reset-view">é‡ç½®è§†å›¾</div>
                    `;
                }
                
                // æ·»åŠ èœå•é¡¹ç‚¹å‡»äº‹ä»¶
                menu.addEventListener('click', (e) => {
                    const action = e.target.dataset.action;
                    this.handleContextMenuAction(action, worldPos, element);
                    menu.remove();
                });
                
                // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
                document.addEventListener('click', function closeMenu() {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                });
                
                this.canvas.parentElement.appendChild(menu);
            }
            
            handleContextMenuAction(action, worldPos, element) {
                switch (action) {
                    case 'create-node':
                        const node = new Node(`èŠ‚ç‚¹${this.nodes.length + 1}`, worldPos.x, worldPos.y);
                        this.nodes.push(node);
                        this.selectedElement = node;
                        this.updatePropertyPanel();
                        break;
                        
                    case 'create-connection':
                        this.creatingConnection = {
                            sourceNode: element,
                            x1: element.x + element.width / 2,
                            y1: element.y + element.height / 2,
                            x2: worldPos.x,
                            y2: worldPos.y
                        };
                        break;
                        
                    case 'delete-node':
                        this.nodes = this.nodes.filter(n => n !== element);
                        // åŒæ—¶åˆ é™¤ç›¸å…³çš„è¿çº¿
                        this.connections = this.connections.filter(
                            c => c.sourceNodeId !== element.id && c.targetNodeId !== element.id
                        );
                        this.selectedElement = null;
                        this.updatePropertyPanel();
                        break;
                        
                    case 'delete-connection':
                        this.connections = this.connections.filter(c => c !== element);
                        this.selectedElement = null;
                        this.updatePropertyPanel();
                        break;
                        
                    case 'reset-view':
                        this.zoom = 1.0;
                        this.pan = { x: 0, y: 0 };
                        document.getElementById('zoom-level').textContent = '100%';
                        break;
                }
                
                this.scheduleRender();
            }
            
            // å±æ€§é¢æ¿
            updatePropertyPanel() {
                const nodeProps = document.getElementById('node-properties');
                const connectionProps = document.getElementById('connection-properties');
                const noSelection = document.getElementById('no-selection');
                
                // éšè—æ‰€æœ‰é¢æ¿
                nodeProps.classList.add('hidden');
                connectionProps.classList.add('hidden');
                noSelection.classList.add('hidden');
                
                if (!this.selectedElement) {
                    noSelection.classList.remove('hidden');
                    return;
                }
                
                if (this.selectedElement.type === 'node') {
                    nodeProps.classList.remove('hidden');
                    const node = this.selectedElement;
                    document.getElementById('node-name').value = node.name;
                    document.getElementById('node-description').value = node.description || '';
                    document.getElementById('node-width').value = node.width;
                    document.getElementById('node-height').value = node.height;
                    document.getElementById('node-autosize').checked = node.autoSize;
                    
                    // æ ¹æ®è‡ªé€‚åº”çŠ¶æ€è®¾ç½®è¾“å…¥æ¡†å¯ç”¨æ€§
                    this.toggleDimensionInputs(!node.autoSize);
                } else if (this.selectedElement.type === 'connection') {
                    connectionProps.classList.remove('hidden');
                    this.updateConditionsList();
                }
            }
            
            toggleDimensionInputs(enabled) {
                document.getElementById('node-width').disabled = !enabled;
                document.getElementById('node-height').disabled = !enabled;
            }
            
            toggleAutoSize(enabled) {
                if (this.selectedElement && this.selectedElement.type === 'node') {
                    this.selectedElement.autoSize = enabled;
                    this.toggleDimensionInputs(!enabled);
                    
                    // å¦‚æœå¯ç”¨è‡ªé€‚åº”ï¼Œç«‹å³é‡æ–°è®¡ç®—å°ºå¯¸
                    if (enabled) {
                        this.selectedElement.calculateAutoSize(this.ctx);
                        this.scheduleRender();
                    }
                }
            }
            
            updateConditionsList() {
                const conditionsList = document.getElementById('conditions-list');
                conditionsList.innerHTML = '';
                
                if (!this.selectedElement || this.selectedElement.type !== 'connection') return;
                
                this.selectedElement.conditions.forEach((condition, index) => {
                    const conditionItem = document.createElement('div');
                    conditionItem.className = 'condition-item';
                    
                    conditionItem.innerHTML = `
                        <div class="condition-header">
                            <span>æ¡ä»¶ ${index + 1}</span>
                            <div class="condition-controls">
                                <button class="delete-condition" data-index="${index}">ğŸ—‘ï¸</button>
                            </div>
                        </div>
                        <div class="condition-fields">
                            <select class="condition-type" data-index="${index}">
                                <option value="int" ${condition.type === 'int' ? 'selected' : ''}>æ•´æ•°</option>
                                <option value="float" ${condition.type === 'float' ? 'selected' : ''}>æµ®ç‚¹æ•°</option>
                                <option value="bool" ${condition.type === 'bool' ? 'selected' : ''}>å¸ƒå°”å€¼</option>
                                <option value="trigger" ${condition.type === 'trigger' ? 'selected' : ''}>è§¦å‘å™¨</option>
                            </select>
                            <input type="text" class="condition-key" value="${condition.key}" placeholder="å‚æ•°å" data-index="${index}">
                            <select class="condition-operator" data-index="${index}">
                                <option value=">" ${condition.operator === '>' ? 'selected' : ''}>></option>
                                <option value="<" ${condition.operator === '<' ? 'selected' : ''}><</option>
                                <option value="==" ${condition.operator === '==' ? 'selected' : ''}>==</option>
                                <option value="!=" ${condition.operator === '!=' ? 'selected' : ''}>!=</option>
                                <option value=">=" ${condition.operator === '>=' ? 'selected' : ''}>>=</option>
                                <option value="<=" ${condition.operator === '<=' ? 'selected' : ''}><=</option>
                            </select>
                            <input type="text" class="condition-value" value="${condition.value}" placeholder="å€¼" data-index="${index}">
                        </div>
                    `;
                    
                    conditionsList.appendChild(conditionItem);
                });
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                conditionsList.querySelectorAll('.condition-type, .condition-key, .condition-operator, .condition-value')
                    .forEach(input => {
                        input.addEventListener('change', (e) => {
                            const index = parseInt(e.target.dataset.index);
                            this.updateCondition(index, e.target.className, e.target.value);
                        });
                    });
                
                conditionsList.querySelectorAll('.delete-condition').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        this.deleteCondition(index);
                    });
                });
            }
            
            updateCondition(index, field, value) {
                if (!this.selectedElement || this.selectedElement.type !== 'connection') return;
                
                const condition = this.selectedElement.conditions[index];
                if (!condition) return;
                
                switch (field) {
                    case 'condition-type':
                        condition.type = value;
                        break;
                    case 'condition-key':
                        condition.key = value;
                        break;
                    case 'condition-operator':
                        condition.operator = value;
                        break;
                    case 'condition-value':
                        condition.value = value;
                        break;
                }
                
                this.scheduleRender();
            }
            
            addCondition() {
                if (!this.selectedElement || this.selectedElement.type !== 'connection') return;
                
                this.selectedElement.conditions.push(new Condition());
                this.updateConditionsList();
                this.scheduleRender();
            }
            
            deleteCondition(index) {
                if (!this.selectedElement || this.selectedElement.type !== 'connection') return;
                
                this.selectedElement.conditions.splice(index, 1);
                this.updateConditionsList();
                this.scheduleRender();
            }
            
            updateSelectedNode() {
                if (!this.selectedElement || this.selectedElement.type !== 'node') return;
                
                const node = this.selectedElement;
                node.name = document.getElementById('node-name').value;
                node.description = document.getElementById('node-description').value;
                
                // æ›´æ–°å°ºå¯¸å±æ€§
                if (!node.autoSize) {
                    node.width = parseInt(document.getElementById('node-width').value) || 120;
                    node.height = parseInt(document.getElementById('node-height').value) || 80;
                } else {
                    // å¦‚æœå¯ç”¨è‡ªé€‚åº”ï¼Œé‡æ–°è®¡ç®—å°ºå¯¸
                    node.calculateAutoSize(this.ctx);
                }
                
                this.scheduleRender();
            }
            
            deleteSelectedNode() {
                if (!this.selectedElement || this.selectedElement.type !== 'node') return;
                
                this.nodes = this.nodes.filter(n => n !== this.selectedElement);
                // åŒæ—¶åˆ é™¤ç›¸å…³çš„è¿çº¿
                this.connections = this.connections.filter(
                    c => c.sourceNodeId !== this.selectedElement.id && c.targetNodeId !== this.selectedElement.id
                );
                this.selectedElement = null;
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            deleteSelectedConnection() {
                if (!this.selectedElement || this.selectedElement.type !== 'connection') return;
                
                this.connections = this.connections.filter(c => c !== this.selectedElement);
                this.selectedElement = null;
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // ç¼©æ”¾æ§åˆ¶
            zoomIn() {
                this.zoom *= 1.2;
                this.zoom = Math.min(5, this.zoom);
                document.getElementById('zoom-level').textContent = Math.round(this.zoom * 100) + '%';
                this.scheduleRender();
            }
            
            zoomOut() {
                this.zoom /= 1.2;
                this.zoom = Math.max(0.1, this.zoom);
                document.getElementById('zoom-level').textContent = Math.round(this.zoom * 100) + '%';
                this.scheduleRender();
            }
            
            // é¡¹ç›®æ“ä½œ
            newProject() {
                this.nodes = [];
                this.connections = [];
                this.selectedElement = null;
                this.zoom = 1.0;
                this.pan = { x: 0, y: 0 };
                document.getElementById('zoom-level').textContent = '100%';
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const content = event.target.result;
                    this.importMarkdown(content);
                };
                reader.readAsText(file);
            }
            
            importMarkdown(content) {
                // ç®€å•çš„Markdownè§£æå™¨
                const lines = content.split('\n');
                let currentSection = null;
                let currentNode = null;
                let currentConnection = null;
                
                this.newProject();
                
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    
                    if (trimmedLine.startsWith('[èŠ‚ç‚¹]')) {
                        currentSection = 'node';
                        currentNode = new Node('', 0, 0);
                        this.nodes.push(currentNode);
                    } else if (trimmedLine.startsWith('[è¿çº¿]')) {
                        currentSection = 'connection';
                        currentConnection = new Connection('', '');
                        this.connections.push(currentConnection);
                    } else if (trimmedLine.startsWith('æ¡ä»¶')) {
                        currentSection = 'condition';
                    } else if (currentSection === 'node' && currentNode) {
                        if (!currentNode.name) {
                            currentNode.name = trimmedLine;
                        } else if (!currentNode.description) {
                            currentNode.description = trimmedLine;
                        }
                    } else if (currentSection === 'connection' && currentConnection) {
                        if (!currentConnection.sourceNodeId) {
                            const sourceNode = this.nodes.find(n => n.name === trimmedLine);
                            if (sourceNode) currentConnection.sourceNodeId = sourceNode.id;
                        } else if (!currentConnection.targetNodeId) {
                            const targetNode = this.nodes.find(n => n.name === trimmedLine);
                            if (targetNode) currentConnection.targetNodeId = targetNode.id;
                        }
                    } else if (currentSection === 'condition' && currentConnection && trimmedLine) {
                        // è§£ææ¡ä»¶ï¼Œæ ¼å¼å¦‚ï¼šA>1
                        const parts = trimmedLine.match(/(\w+)([<>!=]+)(.+)/);
                        if (parts && parts.length >= 4) {
                            const condition = new Condition();
                            condition.key = parts[1];
                            condition.operator = parts[2];
                            condition.value = parts[3];
                            
                            // æ ¹æ®å€¼ç±»å‹æ¨æ–­æ¡ä»¶ç±»å‹
                            if (condition.value.toLowerCase() === 'true' || condition.value.toLowerCase() === 'false') {
                                condition.type = 'bool';
                            } else if (condition.value.includes('.')) {
                                condition.type = 'float';
                            } else {
                                condition.type = 'int';
                            }
                            
                            currentConnection.conditions.push(condition);
                        }
                    }
                }
                
                // éšæœºæ’åˆ—èŠ‚ç‚¹ä½ç½®
                const container = this.canvas.parentElement;
                const centerX = container.clientWidth / 2 / this.zoom;
                const centerY = container.clientHeight / 2 / this.zoom;
                
                this.nodes.forEach((node, i) => {
                    const angle = (i / this.nodes.length) * Math.PI * 2;
                    const radius = 200;
                    node.x = centerX + Math.cos(angle) * radius - node.width / 2;
                    node.y = centerY + Math.sin(angle) * radius - node.height / 2;
                });
                
                this.scheduleRender();
            }
            
            exportMarkdown() {
                let markdown = '';
                
                // å¯¼å‡ºèŠ‚ç‚¹
                this.nodes.forEach(node => {
                    markdown += `[èŠ‚ç‚¹]\n  ${node.name}\n  ${node.description || ''}\n\n`;
                });
                
                // å¯¼å‡ºè¿çº¿
                this.connections.forEach(connection => {
                    const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                    const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                    
                    if (sourceNode && targetNode) {
                        markdown += `[è¿çº¿]\n  ${sourceNode.name}\n  ${targetNode.name}\n`;
                        
                        if (connection.conditions.length > 0) {
                            markdown += '  æ¡ä»¶\n';
                            connection.conditions.forEach(condition => {
                                markdown += `    ${condition.key}${condition.operator}${condition.value}\n`;
                            });
                        }
                        
                        markdown += '\n';
                    }
                });
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'node-graph.md';
                a.click();
                URL.revokeObjectURL(url);
            }
            
            saveProject() {
                this.exportMarkdown();
            }
        }
        
        // åˆå§‹åŒ–ç¼–è¾‘å™¨
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('editor-canvas');
            new NodeGraphEditor(canvas);
        });
    </script>
</body>
</html>