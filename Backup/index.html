<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>节点图形化编辑器</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  
  <!-- Tailwind 配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6',
            secondary: '#10B981',
            neutral: '#64748B',
            dark: '#1E293B',
            light: '#F8FAFC',
            node: '#6366F1',
            connection: '#EC4899'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .tool-item {
        @apply bg-white rounded-md p-3 shadow-sm cursor-move hover:shadow-md transition-shadow border border-gray-200;
      }
      .panel {
        @apply border border-gray-200 bg-white shadow-sm;
      }
      .menu-item {
        @apply px-4 py-2 hover:bg-gray-100 cursor-pointer transition-colors;
      }
      .property-row {
        @apply py-2 border-b border-gray-100 last:border-0;
      }
      .scrollbar-thin {
        scrollbar-width: thin;
      }
      .scrollbar-thin::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      .scrollbar-thin::-webkit-scrollbar-thumb {
        background-color: rgba(100, 116, 139, 0.5);
        border-radius: 3px;
      }
      .context-menu {
        @apply absolute bg-white shadow-lg rounded-md border border-gray-200 py-1 z-50 hidden;
      }
      .context-menu-item {
        @apply px-4 py-2 text-sm hover:bg-gray-100 cursor-pointer;
      }
    }
  </style>
</head>
<body class="bg-gray-50 text-dark h-screen flex flex-col overflow-hidden">
  <!-- 菜单栏 -->
  <header class="bg-white border-b border-gray-200 px-4 py-2 flex items-center space-x-2">
    <div class="flex items-center space-x-1">
      <i class="fa fa-sitemap text-primary text-xl"></i>
      <h1 class="text-lg font-semibold">节点图形化编辑器</h1>
    </div>
    
    <div class="flex ml-4 space-x-1">
      <div class="menu-item flex items-center" id="newFile">
        <i class="fa fa-file-o mr-2"></i>新建
      </div>
      <div class="menu-item flex items-center" id="loadFile">
        <i class="fa fa-folder-open-o mr-2"></i>打开
        <input type="file" id="fileInput" accept=".md" class="hidden">
      </div>
      <div class="menu-item flex items-center" id="saveFile">
        <i class="fa fa-save mr-2"></i>保存
      </div>
    </div>
    
    <div class="flex ml-auto space-x-1">
      <div class="menu-item flex items-center" id="undoBtn">
        <i class="fa fa-undo mr-2"></i>撤销
      </div>
      <div class="menu-item flex items-center" id="redoBtn">
        <i class="fa fa-repeat mr-2"></i>重做
      </div>
      <div class="menu-item flex items-center" id="clearCanvas">
        <i class="fa fa-trash-o mr-2"></i>清空
      </div>
    </div>
  </header>
  
  <!-- 主内容区 -->
  <main class="flex flex-1 overflow-hidden">
    <!-- 工具栏 -->
    <div class="w-40 panel p-3 flex flex-col overflow-y-auto scrollbar-thin">
      <h3 class="text-sm font-medium text-gray-500 mb-3">工具</h3>
      
      <div class="space-y-3">
        <div class="tool-item" draggable="true" data-type="node">
          <div class="flex flex-col items-center">
            <i class="fa fa-square-o text-node text-xl mb-1"></i>
            <span class="text-xs">节点</span>
          </div>
        </div>
      </div>
      
      <h3 class="text-sm font-medium text-gray-500 mt-6 mb-3">条件类型</h3>
      <div class="space-y-2">
        <div class="tool-item text-xs p-2" data-condition="int">
          <i class="fa fa-hashtag mr-1"></i>整数条件
        </div>
        <div class="tool-item text-xs p-2" data-condition="float">
          <i class="fa fa-percent mr-1"></i>浮点条件
        </div>
        <div class="tool-item text-xs p-2" data-condition="bool">
          <i class="fa fa-check-square-o mr-1"></i>布尔条件
        </div>
        <div class="tool-item text-xs p-2" data-condition="trigger">
          <i class="fa fa-bolt mr-1"></i>触发条件
        </div>
      </div>
    </div>
    
    <!-- 工作区 -->
    <div class="flex-1 relative bg-gray-100 overflow-hidden" id="workspace">
      <!-- 连线层 (在节点下方) -->
      <canvas id="connectionsCanvas" class="absolute inset-0 z-0"></canvas>
      <!-- 节点层 (在连线上方) -->
      <canvas id="nodesCanvas" class="absolute inset-0 z-10"></canvas>
      
      <!-- 工作区提示 -->
      <div id="workspaceHint" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400 z-5">
        <i class="fa fa-hand-pointer-o text-4xl mb-4"></i>
        <p>从左侧拖拽节点到此处开始编辑</p>
        <p class="mt-2 text-sm">右键节点可创建连线</p>
      </div>
      
      <!-- 右键菜单 -->
      <div id="contextMenu" class="context-menu">
        <div class="context-menu-item" id="createConnectionFromContext">
          <i class="fa fa-long-arrow-right mr-2 text-connection"></i>创建连线
        </div>
      </div>
    </div>
    
    <!-- 属性栏 -->
    <div class="w-72 panel p-3 overflow-y-auto scrollbar-thin" id="propertyPanel">
      <div id="noSelection" class="flex flex-col items-center justify-center h-full text-gray-400">
        <i class="fa fa-info-circle text-2xl mb-2"></i>
        <p>未选择任何对象</p>
        <p class="mt-1 text-sm">点击节点或连线以查看属性</p>
      </div>
      
      <div id="nodeProperties" class="hidden">
        <h3 class="text-sm font-medium text-gray-500 mb-3">节点属性</h3>
        
        <div class="property-row">
          <label class="text-xs text-gray-500 block mb-1">节点名称</label>
          <input type="text" id="nodeName" class="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-primary">
        </div>
        
        <div class="property-row">
          <label class="text-xs text-gray-500 block mb-1">备注信息</label>
          <textarea id="nodeDescription" rows="4" class="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-primary"></textarea>
        </div>
        
        <div class="mt-4">
          <button id="deleteNode" class="w-full bg-red-50 text-red-600 text-sm py-1 rounded hover:bg-red-100 transition-colors">
            <i class="fa fa-trash-o mr-1"></i>删除节点
          </button>
        </div>
      </div>
      
      <div id="connectionProperties" class="hidden">
        <h3 class="text-sm font-medium text-gray-500 mb-3">连线属性</h3>
        
        <div class="property-row">
          <label class="text-xs text-gray-500 block mb-1">起始节点</label>
          <input type="text" id="connectionStart" class="w-full px-2 py-1 text-sm border border-gray-300 rounded bg-gray-50" readonly>
        </div>
        
        <div class="property-row">
          <label class="text-xs text-gray-500 block mb-1">终止节点</label>
          <input type="text" id="connectionEnd" class="w-full px-2 py-1 text-sm border border-gray-300 rounded bg-gray-50" readonly>
        </div>
        
        <div class="property-row">
          <label class="text-xs text-gray-500 block mb-1">转换条件</label>
          <div id="conditionsList" class="space-y-2 max-h-40 overflow-y-auto scrollbar-thin">
            <!-- 条件列表将动态生成 -->
          </div>
          <button id="addCondition" class="w-full mt-2 bg-green-50 text-green-600 text-xs py-1 rounded hover:bg-green-100 transition-colors">
            <i class="fa fa-plus mr-1"></i>添加条件
          </button>
        </div>
        
        <div class="mt-4">
          <button id="deleteConnection" class="w-full bg-red-50 text-red-600 text-sm py-1 rounded hover:bg-red-100 transition-colors">
            <i class="fa fa-trash-o mr-1"></i>删除连线
          </button>
        </div>
      </div>
    </div>
  </main>
  
  <!-- 状态栏 -->
  <footer class="bg-dark text-white px-4 py-1 text-sm flex items-center">
    <div id="statusInfo" class="flex-1">就绪</div>
    <div id="canvasStats" class="text-right">对象: 0 节点, 0 连线</div>
  </footer>
  
  <!-- 条件编辑弹窗 -->
  <div id="conditionModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="bg-white rounded-lg w-80 p-4 shadow-lg">
      <h3 class="text-sm font-medium mb-3">编辑条件</h3>
      
      <div class="space-y-3">
        <div>
          <label class="text-xs text-gray-500 block mb-1">条件类型</label>
          <select id="conditionType" class="w-full px-2 py-1 text-sm border border-gray-300 rounded">
            <option value="int">整数 (int)</option>
            <option value="float">浮点数 (float)</option>
            <option value="bool">布尔值 (bool)</option>
            <option value="trigger">触发器 (trigger)</option>
          </select>
        </div>
        
        <div id="conditionExpressionContainer">
          <label class="text-xs text-gray-500 block mb-1">表达式</label>
          <input type="text" id="conditionExpression" placeholder="例如: A > 10" class="w-full px-2 py-1 text-sm border border-gray-300 rounded">
        </div>
        
        <div id="triggerNameContainer" class="hidden">
          <label class="text-xs text-gray-500 block mb-1">触发器名称</label>
          <input type="text" id="triggerName" placeholder="例如: OnComplete" class="w-full px-2 py-1 text-sm border border-gray-300 rounded">
        </div>
      </div>
      
      <div class="mt-4 flex justify-end space-x-2">
        <button id="cancelCondition" class="px-3 py-1 text-sm border border-gray-300 rounded hover:bg-gray-50">取消</button>
        <button id="saveCondition" class="px-3 py-1 text-sm bg-primary text-white rounded hover:bg-primary/90">保存</button>
      </div>
    </div>
  </div>

  <script>
    // 应用状态管理
    const appState = {
      nodes: [],
      connections: [],
      nextNodeId: 1,
      nextConnectionId: 1,
      nextConditionId: 1,
      selectedObject: null, // 可以是node或connection
      isDraggingNode: false,
      draggedNode: null,
      dragOffset: { x: 0, y: 0 },
      isDrawingConnection: false,
      connectionStartNode: null,
      canvasOffset: { x: 0, y: 0 },
      scale: 1,
      isPanning: false,
      panStart: { x: 0, y: 0 },
      history: [],
      historyIndex: -1,
      nodesCanvas: null,
      connectionsCanvas: null,
      nodesCtx: null,
      connectionsCtx: null,
      workspaceHint: document.getElementById('workspaceHint'),
      contextMenu: document.getElementById('contextMenu'),
      contextMenuTargetNode: null
    };

    // 节点类
    class Node {
      constructor(x, y) {
        this.id = appState.nextNodeId++;
        this.x = x;
        this.y = y;
        this.width = 120;
        this.height = 80;
        this.name = `节点${this.id}`;
        this.description = '';
      }
      
      // 检查点是否在节点内
      containsPoint(x, y) {
        return x >= this.x - this.width/2 && 
               x <= this.x + this.width/2 && 
               y >= this.y - this.height/2 && 
               y <= this.y + this.height/2;
      }
      
      // 获取节点中心点
      getCenter() {
        return {
          x: this.x,
          y: this.y
        };
      }
    }

    // 条件类
    class Condition {
      constructor(type, expression = '') {
        this.id = appState.nextConditionId++;
        this.type = type; // int, float, bool, trigger
        this.expression = expression;
      }
    }

    // 连接类
    class Connection {
      constructor(startNodeId, endNodeId) {
        this.id = appState.nextConnectionId++;
        this.startNodeId = startNodeId;
        this.endNodeId = endNodeId;
        this.conditions = [];
      }
      
      // 获取起始节点
      getStartNode() {
        return appState.nodes.find(node => node.id === this.startNodeId);
      }
      
      // 获取终止节点
      getEndNode() {
        return appState.nodes.find(node => node.id === this.endNodeId);
      }
    }

    // 初始化Canvas
    function initCanvas() {
      // 分离连线和节点到不同Canvas层，确保连线在节点下方
      appState.nodesCanvas = document.getElementById('nodesCanvas');
      appState.connectionsCanvas = document.getElementById('connectionsCanvas');
      appState.nodesCtx = appState.nodesCanvas.getContext('2d');
      appState.connectionsCtx = appState.connectionsCanvas.getContext('2d');
      
      // 设置Canvas尺寸
      function resizeCanvas() {
        const workspace = document.getElementById('workspace');
        const width = workspace.clientWidth;
        const height = workspace.clientHeight;
        
        appState.nodesCanvas.width = width;
        appState.nodesCanvas.height = height;
        appState.connectionsCanvas.width = width;
        appState.connectionsCanvas.height = height;
        
        renderCanvas();
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // 绑定事件处理
      bindCanvasEvents();
    }

    // 绑定Canvas事件 - 重点修复右键菜单问题
    function bindCanvasEvents() {
      const nodesCanvas = appState.nodesCanvas;
      
      // 右键菜单事件处理
      nodesCanvas.addEventListener('contextmenu', handleContextMenu);
      
      // 鼠标按下事件
      nodesCanvas.addEventListener('mousedown', (e) => {
        const rect = nodesCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - appState.canvasOffset.x) / appState.scale;
        const y = (e.clientY - rect.top - appState.canvasOffset.y) / appState.scale;
        
        // 检查是否点击了节点
        const clickedNode = appState.nodes.find(node => node.containsPoint(x, y));
        
        // 检查是否点击了连线
        let clickedConnection = null;
        if (!clickedNode) {
          clickedConnection = findConnectionAtPoint(x, y);
        }
        
        // 处理拖动节点
        if (clickedNode && e.button === 0) { // 左键
          appState.isDraggingNode = true;
          appState.draggedNode = clickedNode;
          appState.dragOffset.x = x - clickedNode.x;
          appState.dragOffset.y = y - clickedNode.y;
          selectObject(clickedNode);
          recordHistory();
          return;
        }
        
        // 处理选择连线
        if (clickedConnection && e.button === 0) { // 左键
          selectObject(clickedConnection);
          return;
        }
        
        // 处理连线绘制完成
        if (appState.isDrawingConnection && appState.connectionStartNode && e.button === 0) { // 左键
          // 检查是否点击了另一个节点来结束连线
          if (clickedNode && clickedNode.id !== appState.connectionStartNode.id) {
            createConnection(appState.connectionStartNode.id, clickedNode.id);
            appState.isDrawingConnection = false;
            appState.connectionStartNode = null;
          } else {
            // 点击空白处取消连线绘制
            appState.isDrawingConnection = false;
            appState.connectionStartNode = null;
          }
          renderCanvas();
          return;
        }
        
        // 处理画布平移
        if (e.button === 0 && !clickedNode && !clickedConnection) { // 左键点击空白处
          appState.isPanning = true;
          appState.panStart.x = e.clientX;
          appState.panStart.y = e.clientY;
          nodesCanvas.style.cursor = 'grabbing';
          
          // 取消选择
          selectObject(null);
        }
      });
      
      // 专门处理右键点击的函数
      function handleContextMenu(e) {
        e.preventDefault(); // 阻止默认右键菜单
        
        const rect = nodesCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - appState.canvasOffset.x) / appState.scale;
        const y = (e.clientY - rect.top - appState.canvasOffset.y) / appState.scale;
        
        // 检查是否点击了节点
        const clickedNode = appState.nodes.find(node => node.containsPoint(x, y));
        
        if (clickedNode) {
          // 显示右键菜单
          showContextMenu(e.clientX, e.clientY, clickedNode);
        } else {
          // 点击空白处关闭右键菜单
          appState.contextMenu.classList.add('hidden');
        }
      }
      
      // 鼠标移动事件
      nodesCanvas.addEventListener('mousemove', (e) => {
        const rect = nodesCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - appState.canvasOffset.x) / appState.scale;
        const y = (e.clientY - rect.top - appState.canvasOffset.y) / appState.scale;
        
        // 拖动节点
        if (appState.isDraggingNode && appState.draggedNode) {
          appState.draggedNode.x = x - appState.dragOffset.x;
          appState.draggedNode.y = y - appState.dragOffset.y;
          renderCanvas();
          updateStatus(`移动节点: ${appState.draggedNode.name}`);
          return;
        }
        
        // 平移画布
        if (appState.isPanning) {
          const dx = e.clientX - appState.panStart.x;
          const dy = e.clientY - appState.panStart.y;
          appState.canvasOffset.x += dx;
          appState.canvasOffset.y += dy;
          appState.panStart.x = e.clientX;
          appState.panStart.y = e.clientY;
          renderCanvas();
          updateStatus(`平移画布: (${appState.canvasOffset.x.toFixed(0)}, ${appState.canvasOffset.y.toFixed(0)})`);
          return;
        }
        
        // 绘制连线时的预览
        if (appState.isDrawingConnection && appState.connectionStartNode) {
          renderCanvas();
          drawConnectionPreview(
            appState.connectionStartNode.getCenter(), 
            {x, y}
          );
        }
      });
      
      // 鼠标释放事件
      nodesCanvas.addEventListener('mouseup', () => {
        appState.isDraggingNode = false;
        appState.isPanning = false;
        nodesCanvas.style.cursor = 'default';
      });
      
      // 鼠标离开事件
      nodesCanvas.addEventListener('mouseleave', () => {
        appState.isDraggingNode = false;
        appState.isPanning = false;
        nodesCanvas.style.cursor = 'default';
      });
      
      // 滚轮缩放事件
      nodesCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = nodesCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // 计算缩放前鼠标在世界坐标系中的位置
        const worldX = (mouseX - appState.canvasOffset.x) / appState.scale;
        const worldY = (mouseY - appState.canvasOffset.y) / appState.scale;
        
        // 调整缩放比例
        const scaleFactor = e.deltaY < 0 ? 1.1 : 0.9;
        appState.scale = Math.max(0.3, Math.min(appState.scale * scaleFactor, 3));
        
        // 调整偏移量以保持鼠标位置不变
        appState.canvasOffset.x = mouseX - worldX * appState.scale;
        appState.canvasOffset.y = mouseY - worldY * appState.scale;
        
        renderCanvas();
        updateStatus(`缩放: ${appState.scale.toFixed(2)}x`);
      });
      
      // 点击空白处关闭右键菜单
      document.addEventListener('click', (e) => {
        if (!appState.contextMenu.contains(e.target) && e.button === 0) {
          appState.contextMenu.classList.add('hidden');
        }
      });
    }

    // 显示右键菜单
    function showContextMenu(x, y, node) {
      appState.contextMenuTargetNode = node;
      appState.contextMenu.style.left = `${x}px`;
      appState.contextMenu.style.top = `${y}px`;
      appState.contextMenu.classList.remove('hidden');
      
      // 确保菜单不会超出视口
      const menu = appState.contextMenu;
      if (parseInt(menu.style.left) + menu.offsetWidth > window.innerWidth) {
        menu.style.left = `${window.innerWidth - menu.offsetWidth - 10}px`;
      }
      if (parseInt(menu.style.top) + menu.offsetHeight > window.innerHeight) {
        menu.style.top = `${window.innerHeight - menu.offsetHeight - 10}px`;
      }
    }

    // 开始创建连线
    function startCreatingConnection(startNode) {
      appState.isDrawingConnection = true;
      appState.connectionStartNode = startNode;
      updateStatus(`从节点 "${startNode.name}" 开始创建连线，点击目标节点完成`);
      renderCanvas();
    }

    // 渲染Canvas
    function renderCanvas() {
      // 清空画布
      appState.nodesCtx.clearRect(0, 0, appState.nodesCanvas.width, appState.nodesCanvas.height);
      appState.connectionsCtx.clearRect(0, 0, appState.connectionsCanvas.width, appState.connectionsCanvas.height);
      
      // 应用平移和缩放
      appState.nodesCtx.save();
      appState.connectionsCtx.save();
      
      appState.nodesCtx.translate(appState.canvasOffset.x, appState.canvasOffset.y);
      appState.nodesCtx.scale(appState.scale, appState.scale);
      
      appState.connectionsCtx.translate(appState.canvasOffset.x, appState.canvasOffset.y);
      appState.connectionsCtx.scale(appState.scale, appState.scale);
      
      // 绘制网格背景 (在连线层)
      drawGrid(appState.connectionsCtx);
      
      // 绘制连线 (在连线层)
      appState.connections.forEach(connection => {
        drawConnection(appState.connectionsCtx, connection);
      });
      
      // 绘制节点 (在节点层)
      appState.nodes.forEach(node => {
        drawNode(appState.nodesCtx, node);
      });
      
      // 如果正在绘制连线，在节点层上绘制预览
      if (appState.isDrawingConnection && appState.connectionStartNode) {
        // 获取鼠标在世界坐标系中的位置
        const rect = appState.nodesCanvas.getBoundingClientRect();
        const mouseX = (appState.lastMouseX - rect.left - appState.canvasOffset.x) / appState.scale;
        const mouseY = (appState.lastMouseY - rect.top - appState.canvasOffset.y) / appState.scale;
        
        drawConnectionPreview(
          appState.connectionStartNode.getCenter(), 
          {x: mouseX, y: mouseY}
        );
      }
      
      appState.nodesCtx.restore();
      appState.connectionsCtx.restore();
      
      // 更新状态栏统计信息
      updateCanvasStats();
      
      // 检查是否需要显示提示
      checkWorkspaceHint();
    }

    // 绘制网格背景
    function drawGrid(ctx) {
      const gridSize = 30;
      const width = ctx.canvas.width / appState.scale + 100;
      const height = ctx.canvas.height / appState.scale + 100;
      
      ctx.strokeStyle = '#e2e8f0';
      ctx.lineWidth = 1 / appState.scale;
      
      // 计算可见区域的网格范围
      const startX = Math.floor(-appState.canvasOffset.x / appState.scale / gridSize) * gridSize;
      const startY = Math.floor(-appState.canvasOffset.y / appState.scale / gridSize) * gridSize;
      
      // 绘制水平线
      for (let y = startY; y < startY + height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(startX + width, y);
        ctx.stroke();
      }
      
      // 绘制垂直线
      for (let x = startX; x < startX + width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, startY + height);
        ctx.stroke();
      }
    }

    // 绘制节点
    function drawNode(ctx, node) {
      // 节点主体
      ctx.fillStyle = appState.selectedObject === node ? '#818cf8' : '#6366f1';
      ctx.strokeStyle = '#4f46e5';
      ctx.lineWidth = 2;
      
      ctx.beginPath();
      ctx.roundRect(
        node.x - node.width / 2, 
        node.y - node.height / 2, 
        node.width, 
        node.height, 
        6
      );
      ctx.fill();
      ctx.stroke();
      
      // 节点名称
      ctx.fillStyle = 'white';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.name, node.x, node.y - 10);
      
      // 节点ID（小型显示）
      ctx.font = '10px sans-serif';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.fillText(`#${node.id}`, node.x + node.width/2 - 15, node.y - node.height/2 + 12);
    }

    // 绘制连线
    function drawConnection(ctx, connection) {
      const startNode = connection.getStartNode();
      const endNode = connection.getEndNode();
      
      if (!startNode || !endNode) return;
      
      const startPoint = startNode.getCenter();
      const endPoint = endNode.getCenter();
      
      // 绘制线条（直线）
      ctx.strokeStyle = appState.selectedObject === connection ? '#f472b6' : '#ec4899';
      ctx.lineWidth = appState.selectedObject === connection ? 3 : 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      ctx.beginPath();
      ctx.moveTo(startPoint.x, startPoint.y);
      ctx.lineTo(endPoint.x, endPoint.y);
      ctx.stroke();
      
      // 绘制箭头
      drawArrowhead(ctx, endPoint.x, endPoint.y, getAngle(startPoint, endPoint));
      
      // 如果有条件，绘制条件计数
      if (connection.conditions.length > 0) {
        const midPoint = {
          x: (startPoint.x + endPoint.x) / 2,
          y: (startPoint.y + endPoint.y) / 2
        };
        
        ctx.fillStyle = 'white';
        ctx.strokeStyle = appState.selectedObject === connection ? '#f472b6' : '#ec4899';
        ctx.lineWidth = 2;
        
        const text = `${connection.conditions.length}`;
        const textWidth = ctx.measureText(text).width + 8;
        
        ctx.beginPath();
        ctx.roundRect(midPoint.x - textWidth/2, midPoint.y - 12, textWidth, 20, 10);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = appState.selectedObject === connection ? '#f472b6' : '#ec4899';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, midPoint.x, midPoint.y);
      }
    }

    // 绘制连线预览
    function drawConnectionPreview(startPoint, endPoint) {
      const ctx = appState.nodesCtx; // 在节点层绘制预览，确保可见
      
      // 绘制线条（直线）
      ctx.strokeStyle = '#ec4899';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.lineCap = 'round';
      
      ctx.beginPath();
      ctx.moveTo(startPoint.x, startPoint.y);
      ctx.lineTo(endPoint.x, endPoint.y);
      ctx.stroke();
      
      // 绘制箭头
      drawArrowhead(ctx, endPoint.x, endPoint.y, getAngle(startPoint, endPoint));
      
      // 重置线条样式
      ctx.setLineDash([]);
    }

    // 绘制箭头
    function drawArrowhead(ctx, x, y, angle) {
      const size = 8;
      
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-size, size / 2);
      ctx.lineTo(-size, -size / 2);
      ctx.closePath();
      ctx.fillStyle = ctx.strokeStyle;
      ctx.fill();
      
      ctx.restore();
    }

    // 获取角度
    function getAngle(point1, point2) {
      return Math.atan2(point2.y - point1.y, point2.x - point1.x);
    }

    // 在指定点查找连线
    function findConnectionAtPoint(x, y) {
      // 简化处理：检查每个连线是否靠近该点
      for (const connection of appState.connections) {
        const startNode = connection.getStartNode();
        const endNode = connection.getEndNode();
        
        if (!startNode || !endNode) continue;
        
        const startPoint = startNode.getCenter();
        const endPoint = endNode.getCenter();
        
        // 检查点是否靠近直线
        if (isPointNearLine(x, y, startPoint, endPoint, 10)) {
          return connection;
        }
      }
      return null;
    }

    // 检查点是否靠近直线
    function isPointNearLine(x, y, p1, p2, threshold) {
      // 计算点到直线的距离
      const A = x - p1.x;
      const B = y - p1.y;
      const C = p2.x - p1.x;
      const D = p2.y - p1.y;
      
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      
      if (lenSq !== 0) param = dot / lenSq;
      
      let xx, yy;
      
      if (param < 0) {
        xx = p1.x;
        yy = p1.y;
      } else if (param > 1) {
        xx = p2.x;
        yy = p2.y;
      } else {
        xx = p1.x + param * C;
        yy = p1.y + param * D;
      }
      
      const dx = x - xx;
      const dy = y - yy;
      
      return Math.sqrt(dx * dx + dy * dy) < threshold;
    }

    // 创建节点
    function createNode(x, y) {
      const node = new Node(x, y);
      appState.nodes.push(node);
      recordHistory();
      renderCanvas();
      updateStatus(`创建节点: ${node.name}`);
      return node;
    }

    // 创建连线
    function createConnection(startNodeId, endNodeId) {
      // 检查是否已存在相同的连线
      const existingConnection = appState.connections.find(
        conn => conn.startNodeId === startNodeId && conn.endNodeId === endNodeId
      );
      
      if (existingConnection) {
        updateStatus('已存在相同的连线');
        return existingConnection;
      }
      
      const connection = new Connection(startNodeId, endNodeId);
      appState.connections.push(connection);
      recordHistory();
      renderCanvas();
      
      const startNode = appState.nodes.find(n => n.id === startNodeId);
      const endNode = appState.nodes.find(n => n.id === endNodeId);
      updateStatus(`创建连线: ${startNode?.name} -> ${endNode?.name}`);
      
      return connection;
    }

    // 删除节点
    function deleteNode(nodeId) {
      // 同时删除相关的连线
      appState.connections = appState.connections.filter(
        conn => conn.startNodeId !== nodeId && conn.endNodeId !== nodeId
      );
      
      // 删除节点
      appState.nodes = appState.nodes.filter(node => node.id !== nodeId);
      
      // 取消选择
      if (appState.selectedObject && appState.selectedObject.id === nodeId) {
        selectObject(null);
      }
      
      recordHistory();
      renderCanvas();
      updateStatus(`删除节点: #${nodeId}`);
    }

    // 删除连线
    function deleteConnection(connectionId) {
      appState.connections = appState.connections.filter(conn => conn.id !== connectionId);
      
      // 取消选择
      if (appState.selectedObject && appState.selectedObject.id === connectionId) {
        selectObject(null);
      }
      
      recordHistory();
      renderCanvas();
      updateStatus(`删除连线: #${connectionId}`);
    }

    // 为连线添加条件
    function addConditionToConnection(connectionId, type, expression = '') {
      const connection = appState.connections.find(conn => conn.id === connectionId);
      if (!connection) return null;
      
      const condition = new Condition(type, expression);
      connection.conditions.push(condition);
      
      recordHistory();
      renderCanvas();
      updateStatus(`添加条件: ${type}`);
      
      // 如果当前选中的是这个连线，更新属性面板
      if (appState.selectedObject === connection) {
        updateConnectionProperties(connection);
      }
      
      return condition;
    }

    // 更新条件
    function updateCondition(conditionId, type, expression) {
      for (const connection of appState.connections) {
        const condition = connection.conditions.find(cond => cond.id === conditionId);
        if (condition) {
          condition.type = type;
          condition.expression = expression;
          
          recordHistory();
          renderCanvas();
          updateStatus(`更新条件: #${conditionId}`);
          
          // 如果当前选中的是这个连线，更新属性面板
          if (appState.selectedObject === connection) {
            updateConnectionProperties(connection);
          }
          
          return condition;
        }
      }
      return null;
    }

    // 删除条件
    function deleteCondition(conditionId) {
      for (const connection of appState.connections) {
        const index = connection.conditions.findIndex(cond => cond.id === conditionId);
        if (index !== -1) {
          connection.conditions.splice(index, 1);
          
          recordHistory();
          renderCanvas();
          updateStatus(`删除条件: #${conditionId}`);
          
          // 如果当前选中的是这个连线，更新属性面板
          if (appState.selectedObject === connection) {
            updateConnectionProperties(connection);
          }
          
          return true;
        }
      }
      return false;
    }

    // 选择对象（节点或连线）
    function selectObject(object) {
      appState.selectedObject = object;
      
      // 更新属性面板
      const noSelection = document.getElementById('noSelection');
      const nodeProperties = document.getElementById('nodeProperties');
      const connectionProperties = document.getElementById('connectionProperties');
      
      if (!object) {
        noSelection.classList.remove('hidden');
        nodeProperties.classList.add('hidden');
        connectionProperties.classList.add('hidden');
      } else if (object instanceof Node) {
        noSelection.classList.add('hidden');
        nodeProperties.classList.remove('hidden');
        connectionProperties.classList.add('hidden');
        updateNodeProperties(object);
      } else if (object instanceof Connection) {
        noSelection.classList.add('hidden');
        nodeProperties.classList.add('hidden');
        connectionProperties.classList.remove('hidden');
        updateConnectionProperties(object);
      }
      
      renderCanvas();
    }

    // 更新节点属性面板
    function updateNodeProperties(node) {
      const nodeNameInput = document.getElementById('nodeName');
      const nodeDescriptionInput = document.getElementById('nodeDescription');
      
      nodeNameInput.value = node.name;
      nodeDescriptionInput.value = node.description;
      
      // 绑定输入事件
      nodeNameInput.oninput = function() {
        node.name = this.value;
        renderCanvas();
        updateStatus(`更新节点名称: ${node.name}`);
      };
      
      nodeDescriptionInput.oninput = function() {
        node.description = this.value;
        updateStatus(`更新节点描述`);
      };
      
      // 删除节点按钮
      document.getElementById('deleteNode').onclick = function() {
        if (confirm(`确定要删除节点 "${node.name}" 吗？相关连线也将被删除。`)) {
          deleteNode(node.id);
        }
      };
    }

    // 更新连线属性面板
    function updateConnectionProperties(connection) {
      const startNode = connection.getStartNode();
      const endNode = connection.getEndNode();
      
      document.getElementById('connectionStart').value = startNode ? startNode.name : '未知节点';
      document.getElementById('connectionEnd').value = endNode ? endNode.name : '未知节点';
      
      // 更新条件列表
      const conditionsList = document.getElementById('conditionsList');
      conditionsList.innerHTML = '';
      
      if (connection.conditions.length === 0) {
        conditionsList.innerHTML = '<div class="text-xs text-gray-400 italic">无转换条件</div>';
      } else {
        connection.conditions.forEach(condition => {
          const conditionEl = document.createElement('div');
          conditionEl.className = 'flex items-center justify-between bg-gray-50 p-2 rounded text-sm';
          
          const typeIcon = getConditionTypeIcon(condition.type);
          const displayText = condition.type === 'trigger' 
            ? condition.expression || '未命名触发器'
            : condition.expression || '空条件';
          
          conditionEl.innerHTML = `
            <div class="flex items-center">
              <span class="mr-2 text-xs ${getConditionTypeColor(condition.type)}">${typeIcon}</span>
              <span class="text-xs truncate max-w-[140px]">${displayText}</span>
            </div>
            <div class="flex space-x-1">
              <button class="edit-condition text-gray-500 hover:text-primary" data-id="${condition.id}">
                <i class="fa fa-pencil text-xs"></i>
              </button>
              <button class="delete-condition text-gray-500 hover:text-red-500" data-id="${condition.id}">
                <i class="fa fa-times text-xs"></i>
              </button>
            </div>
          `;
          
          conditionsList.appendChild(conditionEl);
        });
        
        // 绑定条件编辑和删除事件
        document.querySelectorAll('.edit-condition').forEach(btn => {
          btn.addEventListener('click', function() {
            const conditionId = parseInt(this.getAttribute('data-id'));
            openConditionEditor(conditionId);
          });
        });
        
        document.querySelectorAll('.delete-condition').forEach(btn => {
          btn.addEventListener('click', function() {
            const conditionId = parseInt(this.getAttribute('data-id'));
            deleteCondition(conditionId);
          });
        });
      }
      
      // 添加条件按钮
      document.getElementById('addCondition').onclick = function() {
        openConditionEditor(null);
      };
      
      // 删除连线按钮
      document.getElementById('deleteConnection').onclick = function() {
        if (confirm('确定要删除这条连线吗？')) {
          deleteConnection(connection.id);
        }
      };
    }

    // 获取条件类型图标
    function getConditionTypeIcon(type) {
      switch(type) {
        case 'int': return '<i class="fa fa-hashtag"></i>';
        case 'float': return '<i class="fa fa-percent"></i>';
        case 'bool': return '<i class="fa fa-check-square-o"></i>';
        case 'trigger': return '<i class="fa fa-bolt"></i>';
        default: return '<i class="fa fa-question"></i>';
      }
    }

    // 获取条件类型颜色
    function getConditionTypeColor(type) {
      switch(type) {
        case 'int': return 'text-blue-500';
        case 'float': return 'text-green-500';
        case 'bool': return 'text-purple-500';
        case 'trigger': return 'text-orange-500';
        default: return 'text-gray-500';
      }
    }

    // 打开条件编辑器
    function openConditionEditor(conditionId) {
      const modal = document.getElementById('conditionModal');
      const typeSelect = document.getElementById('conditionType');
      const expressionInput = document.getElementById('conditionExpression');
      const triggerNameInput = document.getElementById('triggerName');
      const expressionContainer = document.getElementById('conditionExpressionContainer');
      const triggerNameContainer = document.getElementById('triggerNameContainer');
      
      let condition = null;
      let isNew = true;
      
      // 如果是编辑现有条件
      if (conditionId !== null) {
        for (const connection of appState.connections) {
          condition = connection.conditions.find(cond => cond.id === conditionId);
          if (condition) {
            isNew = false;
            break;
          }
        }
        
        if (condition) {
          typeSelect.value = condition.type;
          expressionInput.value = condition.expression;
          triggerNameInput.value = condition.expression;
        }
      } else {
        // 新建条件
        typeSelect.value = 'int';
        expressionInput.value = '';
        triggerNameInput.value = '';
      }
      
      // 根据类型显示不同的输入框
      function updateConditionInputs() {
        if (typeSelect.value === 'trigger') {
          expressionContainer.classList.add('hidden');
          triggerNameContainer.classList.remove('hidden');
        } else {
          expressionContainer.classList.remove('hidden');
          triggerNameContainer.classList.add('hidden');
        }
      }
      
      typeSelect.addEventListener('change', updateConditionInputs);
      updateConditionInputs();
      
      // 显示模态框
      modal.classList.remove('hidden');
      
      // 保存按钮事件
      const saveBtn = document.getElementById('saveCondition');
      const cancelBtn = document.getElementById('cancelCondition');
      
      const saveHandler = function() {
        const type = typeSelect.value;
        let expression = type === 'trigger' 
          ? triggerNameInput.value 
          : expressionInput.value;
        
        if (isNew) {
          // 添加新条件到当前选中的连线
          if (appState.selectedObject instanceof Connection) {
            addConditionToConnection(appState.selectedObject.id, type, expression);
          }
        } else {
          // 更新现有条件
          updateCondition(conditionId, type, expression);
        }
        
        modal.classList.add('hidden');
        saveBtn.removeEventListener('click', saveHandler);
        cancelBtn.removeEventListener('click', cancelHandler);
      };
      
      const cancelHandler = function() {
        modal.classList.add('hidden');
        saveBtn.removeEventListener('click', saveHandler);
        cancelBtn.removeEventListener('click', cancelHandler);
      };
      
      saveBtn.addEventListener('click', saveHandler);
      cancelBtn.addEventListener('click', cancelHandler);
    }

    // 记录历史状态
    function recordHistory() {
      // 移除当前位置之后的历史记录
      if (appState.historyIndex < appState.history.length - 1) {
        appState.history = appState.history.slice(0, appState.historyIndex + 1);
      }
      
      // 保存当前状态的深拷贝
      const stateCopy = {
        nodes: JSON.parse(JSON.stringify(appState.nodes)),
        connections: JSON.parse(JSON.stringify(appState.connections)),
        nextNodeId: appState.nextNodeId,
        nextConnectionId: appState.nextConnectionId,
        nextConditionId: appState.nextConditionId
      };
      
      appState.history.push(stateCopy);
      appState.historyIndex = appState.history.length - 1;
      
      // 限制历史记录数量
      if (appState.history.length > 50) {
        appState.history.shift();
        appState.historyIndex--;
      }
      
      updateStatus(`历史记录更新: ${appState.historyIndex + 1}/${appState.history.length}`);
    }

    // 撤销操作
    function undo() {
      if (appState.historyIndex > 0) {
        appState.historyIndex--;
        restoreHistoryState(appState.history[appState.historyIndex]);
        updateStatus(`撤销: ${appState.historyIndex + 1}/${appState.history.length}`);
      } else {
        updateStatus('已到达最早状态');
      }
    }

    // 重做操作
    function redo() {
      if (appState.historyIndex < appState.history.length - 1) {
        appState.historyIndex++;
        restoreHistoryState(appState.history[appState.historyIndex]);
        updateStatus(`重做: ${appState.historyIndex + 1}/${appState.history.length}`);
      } else {
        updateStatus('已到达最新状态');
      }
    }

    // 恢复历史状态
    function restoreHistoryState(state) {
      // 清空当前状态
      appState.nodes = [];
      appState.connections = [];
      
      // 恢复节点
      state.nodes.forEach(nodeData => {
        const node = new Node(0, 0);
        Object.assign(node, nodeData);
        appState.nodes.push(node);
      });
      
      // 恢复连线
      state.connections.forEach(connData => {
        const connection = new Connection(0, 0);
        Object.assign(connection, connData);
        
        // 恢复条件
        connection.conditions = [];
        connData.conditions.forEach(condData => {
          const condition = new Condition(condData.type, condData.expression);
          condition.id = condData.id;
          connection.conditions.push(condition);
        });
        
        appState.connections.push(connection);
      });
      
      // 恢复ID计数器
      appState.nextNodeId = state.nextNodeId;
      appState.nextConnectionId = state.nextConnectionId;
      appState.nextConditionId = state.nextConditionId;
      
      // 取消选择
      selectObject(null);
      
      // 重新渲染
      renderCanvas();
    }

    // 清空画布
    function clearCanvas() {
      if (confirm('确定要清空所有内容吗？此操作不可恢复。')) {
        appState.nodes = [];
        appState.connections = [];
        selectObject(null);
        recordHistory();
        renderCanvas();
        updateStatus('清空画布');
      }
    }

    // 新建文件
    function newFile() {
      if (appState.nodes.length > 0 || appState.connections.length > 0) {
        if (confirm('确定要新建文件吗？当前内容将被清空。')) {
          appState.nodes = [];
          appState.connections = [];
          appState.nextNodeId = 1;
          appState.nextConnectionId = 1;
          appState.nextConditionId = 1;
          selectObject(null);
          recordHistory();
          renderCanvas();
          updateStatus('新建文件');
        }
      } else {
        // 如果画布为空，直接重置计数器
        appState.nextNodeId = 1;
        appState.nextConnectionId = 1;
        appState.nextConditionId = 1;
        recordHistory();
        updateStatus('新建文件');
      }
    }

    // 检查是否需要显示工作区提示
    function checkWorkspaceHint() {
      if (appState.nodes.length === 0 && appState.connections.length === 0) {
        appState.workspaceHint.classList.remove('hidden');
      } else {
        appState.workspaceHint.classList.add('hidden');
      }
    }

    // 更新状态栏信息
    function updateStatus(text) {
      document.getElementById('statusInfo').textContent = text;
    }

    // 更新画布统计信息
    function updateCanvasStats() {
      const statsEl = document.getElementById('canvasStats');
      statsEl.textContent = `对象: ${appState.nodes.length} 节点, ${appState.connections.length} 连线`;
    }

    // 从Markdown加载数据
    function loadFromMarkdown(markdown) {
      // 清空当前数据
      appState.nodes = [];
      appState.connections = [];
      appState.nextNodeId = 1;
      appState.nextConnectionId = 1;
      appState.nextConditionId = 1;
      
      // 解析Markdown
      const blocks = markdown.split(/^\[节点\]|\[连线\]/gm).filter(block => block.trim() !== '');
      let blockType = null;
      
      blocks.forEach(block => {
        // 确定块类型（第一个块之前没有类型标记，需要特殊处理）
        if (blockType === null) {
          // 检查第一个块是节点还是连线
          if (block.includes('条件') || block.includes('起始节点')) {
            blockType = 'connection';
          } else {
            blockType = 'node';
          }
        }
        
        // 处理节点块
        if (blockType === 'node') {
          const lines = block.trim().split('\n').map(line => line.trim()).filter(line => line !== '');
          if (lines.length >= 1) {
            // 简单布局：节点按网格排列
            const colCount = 4;
            const nodeSpacing = 200;
            const x = (appState.nodes.length % colCount) * nodeSpacing - (colCount - 1) * nodeSpacing / 2;
            const y = Math.floor(appState.nodes.length / colCount) * nodeSpacing - 100;
            
            const node = new Node(x, y);
            node.name = lines[0];
            node.description = lines.slice(1).join('\n');
            appState.nodes.push(node);
            appState.nextNodeId++;
          }
        }
        
        // 处理连线块
        if (blockType === 'connection') {
          const lines = block.trim().split('\n').map(line => line.trim()).filter(line => line !== '');
          if (lines.length >= 2) {
            const startNodeName = lines[0];
            const endNodeName = lines[1];
            
            // 查找节点ID
            const startNode = appState.nodes.find(node => node.name === startNodeName);
            const endNode = appState.nodes.find(node => node.name === endNodeName);
            
            if (startNode && endNode) {
              const connection = new Connection(startNode.id, endNode.id);
              
              // 解析条件
              let inConditions = false;
              lines.forEach(line => {
                if (line === '条件') {
                  inConditions = true;
                } else if (inConditions) {
                  // 简单判断条件类型
                  let type = 'int';
                  if (line.includes('==True') || line.includes('==False')) {
                    type = 'bool';
                  } else if (line.includes('.') || line.includes('float')) {
                    type = 'float';
                  } else if (!line.includes('=') && !line.includes('<') && !line.includes('>')) {
                    type = 'trigger';
                  }
                  
                  connection.conditions.push(new Condition(type, line));
                  appState.nextConditionId++;
                }
              });
              
              appState.connections.push(connection);
              appState.nextConnectionId++;
            }
          }
        }
        
        // 切换块类型
        blockType = blockType === 'node' ? 'connection' : 'node';
      });
      
      selectObject(null);
      recordHistory();
      renderCanvas();
      updateStatus(`从Markdown加载: ${appState.nodes.length}个节点, ${appState.connections.length}个连线`);
    }

    // 保存为Markdown
    function saveToMarkdown() {
      let markdown = '';
      
      // 保存节点
      appState.nodes.forEach(node => {
        markdown += '[节点]\n';
        markdown += `  ${node.name}\n`;
        if (node.description) {
          const descLines = node.description.split('\n');
          descLines.forEach(line => {
            markdown += `  ${line}\n`;
          });
        }
      });
      
      // 保存连线
      appState.connections.forEach(connection => {
        const startNode = connection.getStartNode();
        const endNode = connection.getEndNode();
        
        if (!startNode || !endNode) return;
        
        markdown += '[连线]\n';
        markdown += `  ${startNode.name}\n`;
        markdown += `  ${endNode.name}\n`;
        
        if (connection.conditions.length > 0) {
          markdown += '  条件\n';
          connection.conditions.forEach(condition => {
            markdown += `    ${condition.expression}\n`;
          });
        }
      });
      
      // 创建下载链接
      const blob = new Blob([markdown], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `节点图_${new Date().toISOString().slice(0,10)}.md`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      updateStatus(`保存为Markdown: ${appState.nodes.length}个节点, ${appState.connections.length}个连线`);
    }

    // 绑定工具拖拽事件
    function bindToolEvents() {
      // 节点拖拽
      document.querySelectorAll('[data-type="node"]').forEach(tool => {
        tool.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', 'node');
        });
      });
      
      // 条件类型拖拽
      document.querySelectorAll('[data-condition]').forEach(tool => {
        tool.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', `condition:${tool.getAttribute('data-condition')}`);
        });
      });
      
      // 工作区拖放事件
      const workspace = document.getElementById('workspace');
      
      workspace.addEventListener('dragover', (e) => {
        e.preventDefault();
      });
      
      workspace.addEventListener('drop', (e) => {
        e.preventDefault();
        const data = e.dataTransfer.getData('text/plain');
        
        // 处理节点拖放
        if (data === 'node') {
          const rect = appState.nodesCanvas.getBoundingClientRect();
          const x = (e.clientX - rect.left - appState.canvasOffset.x) / appState.scale;
          const y = (e.clientY - rect.top - appState.canvasOffset.y) / appState.scale;
          
          const newNode = createNode(x, y);
          selectObject(newNode);
        }
        
        // 处理条件拖放
        if (data.startsWith('condition:')) {
          const conditionType = data.split(':')[1];
          if (appState.selectedObject instanceof Connection) {
            addConditionToConnection(appState.selectedObject.id, conditionType);
          } else {
            updateStatus('请先选择一条连线再添加条件');
          }
        }
      });
    }

    // 绑定菜单事件
    function bindMenuEvents() {
      // 新建文件
      document.getElementById('newFile').addEventListener('click', newFile);
      
      // 打开文件
      document.getElementById('loadFile').addEventListener('click', () => {
        document.getElementById('fileInput').click();
      });
      
      document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            loadFromMarkdown(event.target.result);
          };
          reader.readAsText(file);
        }
      });
      
      // 保存文件
      document.getElementById('saveFile').addEventListener('click', saveToMarkdown);
      
      // 撤销
      document.getElementById('undoBtn').addEventListener('click', undo);
      
      // 重做
      document.getElementById('redoBtn').addEventListener('click', redo);
      
      // 清空画布
      document.getElementById('clearCanvas').addEventListener('click', clearCanvas);
      
      // 右键菜单创建连线
      document.getElementById('createConnectionFromContext').addEventListener('click', function() {
        if (appState.contextMenuTargetNode) {
          startCreatingConnection(appState.contextMenuTargetNode);
          appState.contextMenu.classList.add('hidden');
        }
      });
    }

    // 初始化应用
    function initApp() {
      // 存储最后鼠标位置用于连线预览
      appState.lastMouseX = 0;
      appState.lastMouseY = 0;
      document.addEventListener('mousemove', (e) => {
        appState.lastMouseX = e.clientX;
        appState.lastMouseY = e.clientY;
      });
      
      initCanvas();
      bindToolEvents();
      bindMenuEvents();
      recordHistory(); // 记录初始状态
    }

    // 启动应用
    window.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
