<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èŠ‚ç‚¹å›¾å½¢åŒ–ç¼–è¾‘å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #1e1e1e;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        body.light-mode {
            background-color: #f5f5f5;
            color: #333;
        }
        
        .menu-bar {
            background-color: #2d2d30;
            padding: 8px 16px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        body.light-mode .menu-bar {
            background-color: #f0f0f0;
            border-bottom: 1px solid #ccc;
        }
        
        .menu-bar button {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 6px 12px;
            margin-right: 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
        }

        body.light-mode .menu-bar button {
            background-color: #0066cc;
        }
        
        .menu-bar button:hover {
            background-color: #005a9e;
        }

        body.light-mode .menu-bar button:hover {
            background-color: #0052aa;
        }
        
        .menu-group {
            display: flex;
            align-items: center;
        }

        .selection-filter {
            margin: 0 10px;
            padding: 4px 8px;
            background-color: #3c3c3c;
            color: #e0e0e0;
            border: 1px solid #464647;
            border-radius: 3px;
            font-size: 13px;
        }

        body.light-mode .selection-filter {
            background-color: #fff;
            color: #333;
            border: 1px solid #ccc;
        }

        .export-submenu {
            position: relative;
            display: inline-block;
        }

        .export-submenu-content {
            display: none;
            position: absolute;
            background-color: #2d2d30;
            min-width: 120px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
            border-radius: 3px;
        }

        body.light-mode .export-submenu-content {
            background-color: #f0f0f0;
        }

        .export-submenu-content button {
            width: 100%;
            text-align: left;
            margin: 0;
            padding: 8px 12px;
            border-radius: 0;
        }

        .export-submenu:hover .export-submenu-content {
            display: block;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .tool-panel {
            width: 200px;
            background-color: #252526;
            border-right: 1px solid #3e3e42;
            padding: 10px;
        }

        body.light-mode .tool-panel {
            background-color: #e9e9e9;
            border-right: 1px solid #ccc;
        }
        
        .tool-item {
            background-color: #2d2d30;
            border: 1px dashed #4a4a4a;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 4px;
            cursor: grab;
            text-align: center;
            user-select: none;
        }

        body.light-mode .tool-item {
            background-color: #f0f0f0;
            border: 1px dashed #bbb;
            color: #333;
        }
        
        .tool-item:hover {
            background-color: #37373d;
        }

        body.light-mode .tool-item:hover {
            background-color: #d9d9d9;
        }
        
        .workspace {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #1e1e1e;
        }

        body.light-mode .workspace {
            background-color: #f5f5f5;
        }
        
        #editor-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .selection-rectangle {
            position: absolute;
            border: 1px dashed #007acc;
            background-color: rgba(0, 122, 204, 0.1);
            pointer-events: none;
            z-index: 50;
        }
        
        .property-panel {
            width: 300px;
            background-color: #252526;
            border-left: 1px solid #3e3e42;
            padding: 15px;
            overflow-y: auto;
        }

        body.light-mode .property-panel {
            background-color: #e9e9e9;
            border-left: 1px solid #ccc;
        }
        
        .property-section {
            margin-bottom: 20px;
        }
        
        .property-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #cccccc;
            border-bottom: 1px solid #3e3e42;
            padding-bottom: 5px;
        }

        body.light-mode .property-section h3 {
            color: #666;
            border-bottom: 1px solid #ccc;
        }
        
        .form-group {
            margin-bottom: 12px;
        }
        
        .form-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: #969696;
        }

        body.light-mode .form-group label {
            color: #666;
        }
        
        .form-group input, 
        .form-group textarea, 
        .form-group select {
            width: 100%;
            padding: 6px 8px;
            background-color: #3c3c3c;
            border: 1px solid #464647;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 13px;
        }

        body.light-mode .form-group input, 
        body.light-mode .form-group textarea, 
        body.light-mode .form-group select {
            background-color: #fff;
            border: 1px solid #ccc;
            color: #333;
        }
        
        .form-group textarea {
            min-height: 60px;
            resize: vertical;
        }
        
        .condition-item {
            background-color: #2d2d30;
            padding: 8px;
            border-radius: 3px;
            margin-bottom: 8px;
            border-left: 3px solid #007acc;
        }

        body.light-mode .condition-item {
            background-color: #f0f0f0;
            border-left: 3px solid #0066cc;
        }
        
        .condition-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .condition-controls {
            display: flex;
            gap: 5px;
        }
        
        .condition-controls button {
            background: none;
            border: none;
            color: #cccccc;
            cursor: pointer;
            font-size: 12px;
        }

        body.light-mode .condition-controls button {
            color: #666;
        }
        
        .condition-fields {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }
        
        .btn {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        body.light-mode .btn {
            background-color: #0066cc;
        }
        
        .btn:hover {
            background-color: #1177bb;
        }

        body.light-mode .btn:hover {
            background-color: #0052aa;
        }
        
        .btn-danger {
            background-color: #c42b1c;
        }

        body.light-mode .btn-danger {
            background-color: #b32418;
        }
        
        .btn-danger:hover {
            background-color: #da3b2a;
        }

        body.light-mode .btn-danger:hover {
            background-color: #c93222;
        }
        
        .status-bar {
            background-color: #007acc;
            padding: 4px 12px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        body.light-mode .status-bar {
            background-color: #0066cc;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
        }
        
        .zoom-controls button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 2px;
            margin-left: 4px;
            cursor: pointer;
        }
        
        .context-menu {
            position: absolute;
            background-color: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 150px;
        }

        body.light-mode .context-menu {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
        }

        body.light-mode .context-menu-item {
            color: #333;
        }
        
        .context-menu-item:hover {
            background-color: #094771;
        }

        body.light-mode .context-menu-item:hover {
            background-color: #e0e0e0;
        }
        
        .hidden {
            display: none;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
        }
        
        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
    </style>
</head>
<body>
    <!-- é¡¶éƒ¨èœå•æ  -->
    <div class="menu-bar">
        <div class="menu-group">
            <button id="new-project">æ–°å»º</button>
            <button id="import-md">å¯¼å…¥Markdown</button>
            <div class="export-submenu">
                <button id="export-menu">å¯¼å‡º</button>
                <div class="export-submenu-content">
                    <button id="export-md">å¯¼å‡ºMarkdown</button>
                    <button id="export-image">å¯¼å‡ºä¸ºä½å›¾</button>
                </div>
            </div>
            <button id="save-project">ä¿å­˜</button>
            <select id="selection-filter" class="selection-filter">
                <option value="all">é€‰æ‹©æ‰€æœ‰å¯¹è±¡</option>
                <option value="nodes">ä»…é€‰æ‹©èŠ‚ç‚¹</option>
                <option value="connections">ä»…é€‰æ‹©è¿çº¿</option>
            </select>
        </div>
        <div class="menu-group">
            <button id="undo">æ’¤é”€</button>
            <button id="redo">é‡åš</button>
            <button id="toggle-theme">åˆ‡æ¢ä¸»é¢˜</button>
        </div>
    </div>
    
    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content">
        <!-- å·¦ä¾§å·¥å…·æ  -->
        <aside class="tool-panel">
            <div class="tool-item" draggable="true" data-type="node">
                ğŸ“¦ èŠ‚ç‚¹
            </div>
            <div class="tool-item" draggable="true" data-type="connection">
                ğŸ”— è¿çº¿
            </div>
        </aside>
        
        <!-- ä¸­é—´å·¥ä½œåŒº -->
        <section class="workspace">
            <canvas id="editor-canvas"></canvas>
            <div class="selection-rectangle hidden"></div>
        </section>
        
        <!-- å³ä¾§å±æ€§æ  -->
        <aside class="property-panel">
            <div id="node-properties" class="property-section hidden">
                <h3>èŠ‚ç‚¹å±æ€§</h3>
                <div class="form-group">
                    <label for="node-name">èŠ‚ç‚¹åç§°</label>
                    <input type="text" id="node-name">
                </div>
                <div class="form-group">
                    <label for="node-description">èŠ‚ç‚¹æè¿°</label>
                    <textarea id="node-description"></textarea>
                </div>
                
                <!-- æ–°å¢å°ºå¯¸è®¾ç½® -->
                <div class="form-group">
                    <label>å°ºå¯¸è®¾ç½®</label>
                    <div class="checkbox-group">
                        <input type="checkbox" id="node-autosize">
                        <label for="node-autosize">è‡ªé€‚åº”å†…å®¹å°ºå¯¸</label>
                    </div>
                </div>
                
                <div class="form-group dimension-inputs">
                    <div>
                        <label for="node-width">å®½åº¦</label>
                        <input type="number" id="node-width" min="50" max="500" value="120">
                    </div>
                    <div>
                        <label for="node-height">é«˜åº¦</label>
                        <input type="number" id="node-height" min="30" max="300" value="80">
                    </div>
                </div>
                
                <button id="update-node" class="btn">æ›´æ–°èŠ‚ç‚¹</button>
                <button id="delete-node" class="btn btn-danger">åˆ é™¤èŠ‚ç‚¹</button>
            </div>
            
            <div id="connection-properties" class="property-section hidden">
                <h3>è¿çº¿æ¡ä»¶</h3>
                <div id="conditions-list">
                    <!-- æ¡ä»¶é¡¹å°†é€šè¿‡JavaScriptåŠ¨æ€æ·»åŠ  -->
                </div>
                <button id="add-condition" class="btn">æ·»åŠ æ¡ä»¶</button>
                <button id="delete-connection" class="btn btn-danger">åˆ é™¤è¿çº¿</button>
            </div>
            
            <div id="no-selection" class="property-section">
                <h3>æç¤º</h3>
                <p>é€‰æ‹©èŠ‚ç‚¹æˆ–è¿çº¿ä»¥ç¼–è¾‘å…¶å±æ€§</p>
            </div>
        </aside>
    </div>
    
    <!-- åº•éƒ¨çŠ¶æ€æ  -->
    <footer class="status-bar">
        <div class="status-info">å°±ç»ª</div>
        <div class="zoom-controls">
            <button id="zoom-out">-</button>
            <span id="zoom-level">100%</span>
            <button id="zoom-in">+</button>
        </div>
    </footer>
    
    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ï¼Œç”¨äºå¯¼å…¥Markdown -->
    <input type="file" id="file-input" accept=".md" style="display: none;">
    
    <script>
        // ç¦ç”¨é»˜è®¤å³é”®èœå•
        document.addEventListener('DOMContentLoaded', (event) => {
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
        });

        // å†å²è®°å½•é¡¹ç±»
        class HistoryItem {
            constructor(type, data) {
                this.type = type; // 'add', 'delete', 'modify'
                this.data = data;
            }
        }

        // èŠ‚ç‚¹ç±»
        class Node {
            constructor(name, x, y) {
                this.id = crypto.randomUUID();
                this.type = 'node';
                this.name = name;
                this.description = '';
                this.x = x;
                this.y = y;
                
                // æ–°å¢å°ºå¯¸å±æ€§
                this.width = 120;
                this.height = 80;
                this.autoSize = false; // æ˜¯å¦è‡ªé€‚åº”å°ºå¯¸
                this.minWidth = 80;    // æœ€å°å®½åº¦
                this.minHeight = 60;   // æœ€å°é«˜åº¦
                this.padding = 20;     // å†…è¾¹è·
            }
            
            // è®¡ç®—è‡ªé€‚åº”å°ºå¯¸
            calculateAutoSize(ctx) {
                if (!this.autoSize) return;
                
                // æµ‹é‡åç§°æ–‡æœ¬å®½åº¦
                ctx.font = '14px Arial';
                const nameMetrics = ctx.measureText(this.name);
                const nameWidth = nameMetrics.width + this.padding * 2;
                
                // æµ‹é‡æè¿°æ–‡æœ¬å®½åº¦
                let descWidth = 0;
                if (this.description) {
                    ctx.font = '10px Arial';
                    const desc = this.description.length > 30 ? 
                        this.description.substring(0, 30) + '...' : this.description;
                    descWidth = ctx.measureText(desc).width + this.padding * 2;
                }
                
                // è®¡ç®—æœ€ç»ˆå°ºå¯¸
                this.width = Math.max(this.minWidth, nameWidth, descWidth);
                this.height = this.minHeight + (this.description ? 25 : 0);
            }

            // å¤åˆ¶èŠ‚ç‚¹
            clone() {
                const clone = new Node(this.name, this.x, this.y);
                clone.id = this.id;
                clone.description = this.description;
                clone.width = this.width;
                clone.height = this.height;
                clone.autoSize = this.autoSize;
                clone.minWidth = this.minWidth;
                clone.minHeight = this.minHeight;
                clone.padding = this.padding;
                return clone;
            }
        }
        
        // æ¡ä»¶ç±»
        class Condition {
            constructor(type = 'int', key = '', operator = '>', value = '') {
                this.type = type;
                this.key = key;
                this.operator = operator;
                this.value = value;
            }

            clone() {
                return new Condition(this.type, this.key, this.operator, this.value);
            }
        }
        
        // è¿æ¥ç±»
        class Connection {
            constructor(sourceNodeId, targetNodeId) {
                this.id = crypto.randomUUID();
                this.type = 'connection';
                this.sourceNodeId = sourceNodeId;
                this.targetNodeId = targetNodeId;
                this.conditions = [];
            }

            clone() {
                const clone = new Connection(this.sourceNodeId, this.targetNodeId);
                clone.id = this.id;
                clone.conditions = this.conditions.map(cond => cond.clone());
                return clone;
            }
        }
        
        // ç¼–è¾‘å™¨ä¸»ç±»
        class NodeGraphEditor {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // ç¼–è¾‘å™¨çŠ¶æ€
                this.nodes = [];
                this.connections = [];
                this.selectedElements = []; // æ”¯æŒå¤šé€‰
                this.draggingElement = null;
                this.draggingOffset = { x: 0, y: 0 };
                this.creatingConnection = null;
                this.selectionFilter = 'all'; // é€‰æ‹©ç­›é€‰å™¨ï¼š'all', 'nodes', 'connections'
                
                // æ¡†é€‰ç›¸å…³
                this.isSelecting = false;
                this.selectionStart = { x: 0, y: 0 };
                this.selectionRectangle = document.querySelector('.selection-rectangle');
                
                // è§†å›¾çŠ¶æ€
                this.zoom = 1.0;
                this.pan = { x: 0, y: 0 };
                this.isPanning = false;
                this.panStart = { x: 0, y: 0 };
                
                // å†å²è®°å½•
                this.history = [];
                this.historyIndex = -1;
                this.historyLimit = 50; // æœ€å¤šä¿å­˜50æ¡å†å²è®°å½•
                
                // æ€§èƒ½ä¼˜åŒ–
                this.animationId = null;
                this.lastRenderTime = 0;
                this.renderDelay = 16; // ~60FPS
                
                // åˆå§‹åŒ–
                this.setupCanvas();
                this.setupEventListeners();
                this.setupUIListeners();
                this.scheduleRender();
                // ç»‘å®šå…¨å±€äº‹ä»¶å¤„ç†å‡½æ•°çš„thisä¸Šä¸‹æ–‡
                this.globalMouseMoveHandler = (e) => this.handleGlobalMouseMove(e);
                this.globalMouseUpHandler = (e) => this.handleGlobalMouseUp(e);
                
                // åˆå§‹åŒ–é€‰æ‹©æ¡†å½“å‰ä½ç½®
                this.selectionCurrent = { x: 0, y: 0 };
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.scheduleRender();
            }
            
            handleGlobalMouseMove(e) {
                if (!this.isSelecting) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // æ›´æ–°é€‰æ‹©æ¡†ä½ç½®å’Œå¤§å°
                const left = Math.min(x, this.selectionStart.x);
                const top = Math.min(y, this.selectionStart.y);
                const width = Math.abs(x - this.selectionStart.x);
                const height = Math.abs(y - this.selectionStart.y);
                
                this.selectionCurrent.x = x;
                this.selectionCurrent.y = y;
                this.selectionRectangle.style.left = left + 'px';
                this.selectionRectangle.style.top = top + 'px';
                this.selectionRectangle.style.width = width + 'px';
                this.selectionRectangle.style.height = height + 'px';
            }
            handleGlobalMouseUp(e) {
                if (!this.isSelecting) return;
                
                // ç§»é™¤å…¨å±€äº‹ä»¶ç›‘å¬
                document.removeEventListener('mousemove', this.globalMouseMoveHandler);
                document.removeEventListener('mouseup', this.globalMouseUpHandler);
                
                // å¤„ç†æ¡†é€‰å®Œæˆé€»è¾‘
                this.isSelecting = false;
                this.selectionRectangle.classList.add('hidden');
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // è®¡ç®—é€‰æ‹©æ¡†çš„ä¸–ç•Œåæ ‡
                const start = this.screenToWorld(this.selectionStart.x, this.selectionStart.y);
                const end = this.screenToWorld(x, y);
                
                const selectionMinX = Math.min(start.x, end.x);
                const selectionMinY = Math.min(start.y, end.y);
                const selectionMaxX = Math.max(start.x, end.x);
                const selectionMaxY = Math.max(start.y, end.y);
                
                // åŸæœ‰æ¡†é€‰å…ƒç´ å¤„ç†é€»è¾‘...
                this.processSelection(selectionMinX, selectionMinY, selectionMaxX, selectionMaxY);
                
                this.draggingElement = null;
                this.isPanning = false;
                this.scheduleRender();
            }
            // 1. ä¿®æ”¹é¼ æ ‡äº‹ä»¶ç›‘å¬ï¼Œä½¿ç”¨ä¸­é”®å¹³ç§»å¹¶ä¿®å¤å³é”®èœå•
            setupEventListeners() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                
                // é˜»æ­¢é»˜è®¤å³é”®èœå•
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // æ‹–æ”¾äº‹ä»¶
                this.canvas.addEventListener('dragover', (e) => e.preventDefault());
                this.canvas.addEventListener('drop', (e) => this.handleDrop(e));

                // æ–°å¢ï¼šæ•è·é¼ æ ‡ç¦»å¼€äº‹ä»¶ç”¨äºæ¡†é€‰
                this.canvas.addEventListener('mouseleave', (e) => this.handleMouseLeave(e));
            }
            // 4. ä¿®å¤é¼ æ ‡ç¦»å¼€ç”»å¸ƒæ—¶çš„å¤„ç†
            handleMouseLeave(e) {
                // æ¡†é€‰è¿‡ç¨‹ä¸­é¼ æ ‡ç¦»å¼€ç”»å¸ƒæ—¶ä¸ç»“æŸæ¡†é€‰
                if (this.isSelecting) {
                    return;
                }
                // å…¶ä»–é€»è¾‘...
            }
            
            setupUIListeners() {
                // èœå•æŒ‰é’®
                document.getElementById('new-project').addEventListener('click', () => this.newProject());
                document.getElementById('import-md').addEventListener('click', () => document.getElementById('file-input').click());
                document.getElementById('export-md').addEventListener('click', () => this.exportMarkdown());
                document.getElementById('export-image').addEventListener('click', () => this.exportAsImage());
                document.getElementById('save-project').addEventListener('click', () => this.saveProject());
                document.getElementById('undo').addEventListener('click', () => this.undo());
                document.getElementById('redo').addEventListener('click', () => this.redo());
                document.getElementById('toggle-theme').addEventListener('click', () => this.toggleTheme());
                
                // é€‰æ‹©ç­›é€‰å™¨
                document.getElementById('selection-filter').addEventListener('change', (e) => {
                    this.selectionFilter = e.target.value;
                    // æ¸…é™¤ä¸ç¬¦åˆå½“å‰ç­›é€‰å™¨çš„é€‰æ‹©
                    this.selectedElements = this.selectedElements.filter(el => {
                        if (this.selectionFilter === 'all') return true;
                        if (this.selectionFilter === 'nodes' && el.type === 'node') return true;
                        if (this.selectionFilter === 'connections' && el.type === 'connection') return true;
                        return false;
                    });
                    this.updatePropertyPanel();
                    this.scheduleRender();
                });
                
                // ç¼©æ”¾æ§åˆ¶
                document.getElementById('zoom-in').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoom-out').addEventListener('click', () => this.zoomOut());
                
                // å±æ€§é¢æ¿
                document.getElementById('update-node').addEventListener('click', () => this.updateSelectedNode());
                document.getElementById('delete-node').addEventListener('click', () => this.deleteSelectedNodes());
                document.getElementById('add-condition').addEventListener('click', () => this.addCondition());
                document.getElementById('delete-connection').addEventListener('click', () => this.deleteSelectedConnections());
                
                // è‡ªé€‚åº”å°ºå¯¸åˆ‡æ¢
                document.getElementById('node-autosize').addEventListener('change', (e) => {
                    this.toggleAutoSize(e.target.checked);
                });
                
                // æ–‡ä»¶è¾“å…¥
                document.getElementById('file-input').addEventListener('change', (e) => this.handleFileSelect(e));
                
                // å·¥å…·æ æ‹–æ‹½
                document.querySelectorAll('.tool-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', item.dataset.type);
                    });
                });
            }
            
            // æ·»åŠ å†å²è®°å½•
            addHistory(type, data) {
                // å¦‚æœå½“å‰ä¸åœ¨å†å²è®°å½•æœ«å°¾ï¼Œæ¸…é™¤åé¢çš„è®°å½•
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                
                // æ·»åŠ æ–°è®°å½•
                this.history.push(new HistoryItem(type, data));
                this.historyIndex++;
                
                // å¦‚æœè¶…å‡ºé™åˆ¶ï¼Œç§»é™¤æœ€æ—©çš„è®°å½•
                if (this.history.length > this.historyLimit) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }
            
            // æ’¤é”€æ“ä½œ
            undo() {
                if (this.historyIndex < 0) return;
                
                const item = this.history[this.historyIndex];
                this.historyIndex--;
                
                switch (item.type) {
                    case 'add-node':
                        // æ’¤é”€æ·»åŠ èŠ‚ç‚¹ï¼šåˆ é™¤èŠ‚ç‚¹
                        const nodeIndex = this.nodes.findIndex(n => n.id === item.data.id);
                        if (nodeIndex !== -1) {
                            this.nodes.splice(nodeIndex, 1);
                        }
                        // åŒæ—¶åˆ é™¤ç›¸å…³è¿çº¿
                        this.connections = this.connections.filter(conn => 
                            conn.sourceNodeId !== item.data.id && conn.targetNodeId !== item.data.id
                        );
                        break;
                        
                    case 'add-connection':
                        // æ’¤é”€æ·»åŠ è¿çº¿ï¼šåˆ é™¤è¿çº¿
                        const connIndex = this.connections.findIndex(c => c.id === item.data.id);
                        if (connIndex !== -1) {
                            this.connections.splice(connIndex, 1);
                        }
                        break;
                        
                    case 'delete-nodes':
                        // æ’¤é”€åˆ é™¤èŠ‚ç‚¹ï¼šæ¢å¤èŠ‚ç‚¹
                        this.nodes.push(...item.data.nodes);
                        // æ¢å¤ç›¸å…³è¿çº¿
                        this.connections.push(...item.data.connections);
                        break;
                        
                    case 'delete-connections':
                        // æ’¤é”€åˆ é™¤è¿çº¿ï¼šæ¢å¤è¿çº¿
                        this.connections.push(...item.data);
                        break;
                        
                    case 'modify-node':
                        // æ’¤é”€ä¿®æ”¹èŠ‚ç‚¹ï¼šæ¢å¤æ—§å€¼
                        const nodeToRestore = this.nodes.find(n => n.id === item.data.id);
                        if (nodeToRestore) {
                            Object.assign(nodeToRestore, item.data.oldValue);
                        }
                        break;
                }
                
                this.selectedElements = [];
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // é‡åšæ“ä½œ
            redo() {
                if (this.historyIndex >= this.history.length - 1) return;
                
                this.historyIndex++;
                const item = this.history[this.historyIndex];
                
                switch (item.type) {
                    case 'add-node':
                        // é‡åšæ·»åŠ èŠ‚ç‚¹
                        this.nodes.push(item.data);
                        break;
                        
                    case 'add-connection':
                        // é‡åšæ·»åŠ è¿çº¿
                        this.connections.push(item.data);
                        break;
                        
                    case 'delete-nodes':
                        // é‡åšåˆ é™¤èŠ‚ç‚¹
                        const nodeIds = item.data.nodes.map(n => n.id);
                        this.nodes = this.nodes.filter(n => !nodeIds.includes(n.id));
                        this.connections = this.connections.filter(conn => 
                            !nodeIds.includes(conn.sourceNodeId) && !nodeIds.includes(conn.targetNodeId)
                        );
                        break;
                        
                    case 'delete-connections':
                        // é‡åšåˆ é™¤è¿çº¿
                        const connIds = item.data.map(c => c.id);
                        this.connections = this.connections.filter(c => !connIds.includes(c.id));
                        break;
                        
                    case 'modify-node':
                        // é‡åšä¿®æ”¹èŠ‚ç‚¹
                        const nodeToModify = this.nodes.find(n => n.id === item.data.id);
                        if (nodeToModify) {
                            Object.assign(nodeToModify, item.data.newValue);
                        }
                        break;
                }
                
                this.selectedElements = [];
                this.updatePropertyPanel();
                this.scheduleRender();
            }
            
            // åˆ‡æ¢ä¸»é¢˜
            toggleTheme() {
                document.body.classList.toggle('light-mode');
                this.scheduleRender();
            }
            
            // å¯¼å‡ºä¸ºå›¾ç‰‡
            exportAsImage() {
                // åˆ›å»ºä¸€ä¸ªä¸´æ—¶canvasç”¨äºå¯¼å‡º
                const exportCanvas = document.createElement('canvas');
                const ctx = exportCanvas.getContext('2d');
                
                // è®¡ç®—æ‰€æœ‰å…ƒç´ çš„è¾¹ç•Œæ¡†
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                // è€ƒè™‘æ‰€æœ‰èŠ‚ç‚¹
                this.nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x + node.width);
                    maxY = Math.max(maxY, node.y + node.height);
                });
                
                // è€ƒè™‘è¿çº¿çš„èµ·ç‚¹å’Œç»ˆç‚¹
                this.connections.forEach(connection => {
                    const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                    const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                    
                    if (sourceNode && targetNode) {
                        const startX = sourceNode.x + sourceNode.width / 2;
                        const startY = sourceNode.y + sourceNode.height / 2;
                        const endX = targetNode.x + targetNode.width / 2;
                        const endY = targetNode.y + targetNode.height / 2;
                        
                        minX = Math.min(minX, startX, endX);
                        minY = Math.min(minY, startY, endY);
                        maxX = Math.max(maxX, startX, endX);
                        maxY = Math.max(maxY, startY, endY);
                    }
                });
                
                // å¦‚æœæ²¡æœ‰å…ƒç´ ï¼Œä½¿ç”¨é»˜è®¤å°ºå¯¸
                if (this.nodes.length === 0 && this.connections.length === 0) {
                    minX = 0;
                    minY = 0;
                    maxX = 800;
                    maxY = 600;
                } else {
                    // æ·»åŠ è¾¹è·
                    const padding = 50;
                    minX -= padding;
                    minY -= padding;
                    maxX += padding;
                    maxY += padding;
                }
                
                // è®¾ç½®å¯¼å‡ºcanvaså°ºå¯¸
                const width = maxX - minX;
                const height = maxY - minY;
                exportCanvas.width = width;
                exportCanvas.height = height;
                
                // ä¿å­˜å½“å‰è§†å›¾çŠ¶æ€
                const originalPan = { ...this.pan };
                const originalZoom = this.zoom;
                const originalSelectedElements = [...this.selectedElements];
                
                // ä¸´æ—¶è°ƒæ•´è§†å›¾ä»¥é€‚åº”æ‰€æœ‰å…ƒç´ 
                this.pan.x = -minX;
                this.pan.y = -minY;
                this.zoom = 1;
                this.selectedElements = [];
                
                // æ¸²æŸ“åˆ°å¯¼å‡ºcanvas
                ctx.fillStyle = document.body.classList.contains('light-mode') ? '#f5f5f5' : '#1e1e1e';
                ctx.fillRect(0, 0, width, height);
                
                // ç»˜åˆ¶ç½‘æ ¼
                this.drawGrid(ctx, width, height, minX, minY, maxX, maxY);
                
                // ç»˜åˆ¶è¿çº¿
                this.connections.forEach(connection => {
                    this.drawConnection(connection, false, ctx);
                });
                
                // ç»˜åˆ¶èŠ‚ç‚¹
                this.nodes.forEach(node => {
                    this.drawNode(node, false, ctx);
                });
                
                // æ¢å¤åŸå§‹è§†å›¾çŠ¶æ€
                this.pan = originalPan;
                this.zoom = originalZoom;
                this.selectedElements = originalSelectedElements;
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const link = document.createElement('a');
                link.download = 'èŠ‚ç‚¹å›¾_' + new Date().toISOString().slice(0,10) + '.png';
                link.href = exportCanvas.toDataURL('image/png');
                link.click();
                
                this.scheduleRender();
            }
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šèŠ‚æµæ¸²æŸ“
            scheduleRender() {
                if (this.animationId) return;
                
                this.animationId = requestAnimationFrame((timestamp) => {
                    if (timestamp - this.lastRenderTime > this.renderDelay) {
                        this.render();
                        this.lastRenderTime = timestamp;
                    }
                    this.animationId = null;
                });
            }
            
            // åæ ‡è½¬æ¢
            screenToWorld(x, y) {
                return {
                    x: (x - this.pan.x) / this.zoom,
                    y: (y - this.pan.y) / this.zoom
                };
            }
            
            worldToScreen(x, y) {
                return {
                    x: x * this.zoom + this.pan.x,
                    y: y * this.zoom + this.pan.y
                };
            }
            
            // æ·»åŠ å¼€å§‹æ¡†é€‰çš„æ–¹æ³•
            startSelection(x, y) {
                this.isSelecting = true;
                this.selectionStart.x = x;
                this.selectionStart.y = y;
                this.selectionCurrent.x = x;
                this.selectionCurrent.y = y;
                
                // æ˜¾ç¤ºé€‰æ‹©æ¡†
                this.selectionRectangle.style.left = x + 'px';
                this.selectionRectangle.style.top = y + 'px';
                this.selectionRectangle.style.width = '0px';
                this.selectionRectangle.style.height = '0px';
                this.selectionRectangle.classList.remove('hidden');
                
                // æ·»åŠ å…¨å±€äº‹ä»¶ç›‘å¬ï¼Œä»¥ä¾¿åœ¨é¼ æ ‡ç§»å‡ºç”»å¸ƒæ—¶ä»èƒ½è·Ÿè¸ª
                document.addEventListener('mousemove', this.globalMouseMoveHandler);
                document.addEventListener('mouseup', this.globalMouseUpHandler);
            }

            // é¼ æ ‡äº‹ä»¶å¤„ç†
            // 2. ä¿®æ”¹é¼ æ ‡æŒ‰ä¸‹å¤„ç†ï¼Œä½¿ç”¨ä¸­é”®(press=1)è¿›è¡Œå¹³ç§»
            handleMouseDown(e) {
    const rect = this.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const worldPos = this.screenToWorld(x, y);

    // å³é”®ç‚¹å‡» - æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
    if (e.button === 2) {
        // å…ˆéšè—ä»»ä½•å·²æ˜¾ç¤ºçš„ä¸Šä¸‹æ–‡èœå•
        this.hideContextMenu();
        
        // æ£€æŸ¥ç‚¹å‡»ä½ç½®æ˜¯å¦æœ‰å…ƒç´ 
        const clickedElement = this.getElementAtPosition(worldPos.x, worldPos.y);
        
        // å¦‚æœæ²¡æœ‰æŒ‰ä¸‹Ctrlé”®ï¼Œæ¸…é™¤å½“å‰é€‰æ‹©
        if (!e.ctrlKey && !e.metaKey) {
            this.selectedElements = [];
        }
        
        // å¦‚æœç‚¹å‡»äº†å…ƒç´ ï¼Œå°†å…¶æ·»åŠ åˆ°é€‰æ‹©ä¸­
        if (clickedElement) {
            // æ£€æŸ¥æ˜¯å¦ç¬¦åˆå½“å‰é€‰æ‹©ç­›é€‰å™¨
            const isAllowed = this.selectionFilter === 'all' || 
                            (this.selectionFilter === 'nodes' && clickedElement.type === 'node') ||
                            (this.selectionFilter === 'connections' && clickedElement.type === 'connection');
            
            if (isAllowed) {
                // å¦‚æœå·²ç»é€‰ä¸­ï¼Œå°±ç§»é™¤å®ƒï¼Œå¦åˆ™æ·»åŠ å®ƒ
                const index = this.selectedElements.findIndex(el => el.id === clickedElement.id);
                if (index > -1) {
                    this.selectedElements.splice(index, 1);
                } else {
                    this.selectedElements.push(clickedElement);
                }
            }
        }
        
        this.updatePropertyPanel();
        
        // å¦‚æœæœ‰é€‰ä¸­çš„å…ƒç´ ï¼Œæ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
        if (this.selectedElements.length > 0) {
            this.showContextMenu(e.clientX, e.clientY);
        }
        
        this.scheduleRender();
        return; // å³é”®ç‚¹å‡»ä¸æ‰§è¡Œå…¶ä»–æ“ä½œ
    }

    // å·¦é”®ç‚¹å‡» - å¤„ç†é€‰æ‹©å’Œæ‹–æ‹½
    if (e.button === 0) {
        // å¦‚æœæ²¡æœ‰æŒ‰ä¸‹Ctrlé”®ï¼Œæ¸…é™¤å½“å‰é€‰æ‹©
        if (!e.ctrlKey && !e.metaKey) {
            this.selectedElements = [];
        }

        // æ£€æŸ¥ç‚¹å‡»ä½ç½®æ˜¯å¦æœ‰å…ƒç´ 
        const clickedElement = this.getElementAtPosition(worldPos.x, worldPos.y);
        
        if (clickedElement) {
            // å¤„ç†å…ƒç´ ç‚¹å‡»
            this.handleElementClick(clickedElement, worldPos, e);
        } else {
            // æ²¡æœ‰ç‚¹å‡»åˆ°ä»»ä½•å…ƒç´ ï¼Œå¼€å§‹æ¡†é€‰
            this.startSelection(x, y);
        }
        
        this.updatePropertyPanel();
        this.scheduleRender();
    }

    // ä¸­é”®ç‚¹å‡» - å¹³ç§»
    if (e.button === 1) {
        this.isPanning = true;
        this.panStart.x = x;
        this.panStart.y = y;
        this.canvas.style.cursor = 'grabbing';
    }
}
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                // æ›´æ–°çŠ¶æ€æ 
                document.querySelector('.status-info').textContent = 
                    `X: ${Math.round(worldPos.x)}, Y: ${Math.round(worldPos.y)} ç¼©æ”¾: ${Math.round(this.zoom * 100)}%`;
                
                if (this.draggingElement) {
                    // æ‹–åŠ¨èŠ‚ç‚¹
                    const oldX = this.draggingElement.x;
                    const oldY = this.draggingElement.y;
                    
                    this.draggingElement.x = worldPos.x - this.draggingOffset.x;
                    this.draggingElement.y = worldPos.y - this.draggingOffset.y;
                    
                    // è®°å½•å†å²
                    if (oldX !== this.draggingElement.x || oldY !== this.draggingElement.y) {
                        this.addHistory('modify-node', {
                            id: this.draggingElement.id,
                            oldValue: { x: oldX, y: oldY },
                            newValue: { x: this.draggingElement.x, y: this.draggingElement.y }
                        });
                    }
                    
                    this.scheduleRender();
                } else if (this.creatingConnection) {
                    // æ›´æ–°è¿çº¿é¢„è§ˆ
                    this.creatingConnection.x2 = worldPos.x;
                    this.creatingConnection.y2 = worldPos.y;
                    this.scheduleRender();
                } else if (this.isPanning) {
                    // å¹³ç§»è§†å›¾
                    this.pan.x += x - this.panStart.x;
                    this.pan.y += y - this.panStart.y;
                    this.panStart.x = x;
                    this.panStart.y = y;
                    this.scheduleRender();
                } else if (this.isSelecting) {
                    // æ›´æ–°é€‰æ‹©æ¡†
                    const left = Math.min(x, this.selectionStart.x);
                    const top = Math.min(y, this.selectionStart.y);
                    const width = Math.abs(x - this.selectionStart.x);
                    const height = Math.abs(y - this.selectionStart.y);
                    
                    this.selectionRectangle.style.left = left + 'px';
                    this.selectionRectangle.style.top = top + 'px';
                    this.selectionRectangle.style.width = width + 'px';
                    this.selectionRectangle.style.height = height + 'px';
                }
            }
            
            handleMouseUp(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                // ä¸­é”®é‡Šæ”¾ï¼šç»“æŸå¹³ç§»
                if (e.button === 1) {
                    this.isPanning = false;
                    this.canvas.style.cursor = 'default';
                    return;
                }
                
                // å³é”®é‡Šæ”¾ï¼šä»…åœ¨æœªç§»åŠ¨æ—¶æ˜¾ç¤ºèœå•
                if (e.button === 2) {
                    // æ£€æŸ¥é¼ æ ‡æ˜¯å¦æœ‰æ˜¾è‘—ç§»åŠ¨ï¼ˆé˜ˆå€¼ä¸º3åƒç´ ï¼‰
                    const moveThreshold = 3;
                    const dx = Math.abs(x - this.panStart.x);
                    const dy = Math.abs(y - this.panStart.y);
                    
                    // åªæœ‰å½“ç§»åŠ¨è·ç¦»å°äºé˜ˆå€¼æ—¶æ‰æ˜¾ç¤ºèœå•
                    if (dx < moveThreshold && dy < moveThreshold) {
                        this.showContextMenu(x, y);
                    }
                    
                    // æ— è®ºæ˜¯å¦æ˜¾ç¤ºèœå•ï¼Œéƒ½ç»“æŸå¯èƒ½çš„å¹³ç§»çŠ¶æ€
                    this.isPanning = false;
                    return;
                }
                
                // å·¦é”®é‡Šæ”¾å¤„ç†
                if (e.button === 0) {
                    // å¤„ç†æ¡†é€‰ç»“æŸ
                    if (this.isSelecting) {
                        this.isSelecting = false;
                        this.selectionRectangle.classList.add('hidden');
                        
                        // è®¡ç®—é€‰æ‹©æ¡†çš„ä¸–ç•Œåæ ‡èŒƒå›´
                        const start = this.screenToWorld(this.selectionStart.x, this.selectionStart.y);
                        const end = this.screenToWorld(x, y);
                        
                        const selectionMinX = Math.min(start.x, end.x);
                        const selectionMinY = Math.min(start.y, end.y);
                        const selectionMaxX = Math.max(start.x, end.x);
                        const selectionMaxY = Math.max(start.y, end.y);
                        
                        // å¤„ç†é€‰ä¸­çš„å…ƒç´ 
                        this.processSelection(selectionMinX, selectionMinY, selectionMaxX, selectionMaxY);
                        
                        // ç§»é™¤å…¨å±€äº‹ä»¶ç›‘å¬
                        document.removeEventListener('mousemove', this.globalMouseMoveHandler);
                        document.removeEventListener('mouseup', this.globalMouseUpHandler);
                    }
                    
                    // ç»“æŸèŠ‚ç‚¹æ‹–åŠ¨
                    if (this.draggingElement) {
                        this.draggingElement = null;
                    }
                    
                    // ç»“æŸè¿çº¿åˆ›å»º
                    if (this.creatingConnection) {
                        // å°è¯•è¿æ¥åˆ°ç›®æ ‡èŠ‚ç‚¹
                        const targetElement = this.getElementAt(worldPos.x, worldPos.y);
                        if (targetElement && targetElement.type === 'node' && 
                            targetElement.id !== this.creatingConnection.sourceNode.id) {
                            // åˆ›å»ºæ–°è¿æ¥
                            this.createConnection(
                                this.creatingConnection.sourceNode.id,
                                targetElement.id
                            );
                        }
                        this.creatingConnection = null;
                    }
                    
                    this.scheduleRender();
                }
            }
                        
            // æ£€æŸ¥çº¿æ®µæ˜¯å¦ä¸çŸ©å½¢ç›¸äº¤
            lineIntersectsRectangle(x1, y1, x2, y2, rx1, ry1, rx2, ry2) {
                // æ£€æŸ¥çº¿æ®µçš„ä¸¤ä¸ªç«¯ç‚¹æ˜¯å¦åœ¨çŸ©å½¢å†…
                const point1In = x1 >= rx1 && x1 <= rx2 && y1 >= ry1 && y1 <= ry2;
                const point2In = x2 >= rx1 && x2 <= rx2 && y2 >= ry1 && y2 <= ry2;
                
                if (point1In || point2In) return true;
                
                // æ£€æŸ¥çº¿æ®µæ˜¯å¦ä¸çŸ©å½¢çš„å››æ¡è¾¹ç›¸äº¤
                const edges = [
                    [rx1, ry1, rx2, ry1], // ä¸Šè¾¹
                    [rx2, ry1, rx2, ry2], // å³è¾¹
                    [rx1, ry2, rx2, ry2], // ä¸‹è¾¹
                    [rx1, ry1, rx1, ry2]  // å·¦è¾¹
                ];
                
                return edges.some(edge => 
                    this.lineSegmentsIntersect(x1, y1, x2, y2, edge[0], edge[1], edge[2], edge[3])
                );
            }
            
            // æ£€æŸ¥ä¸¤æ¡çº¿æ®µæ˜¯å¦ç›¸äº¤
            lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
                const ccw = (A, B, C) => (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
                return ccw({x:x1,y:y1}, {x:x3,y:y3}, {x:x4,y:y4}) !== ccw({x:x2,y:y2}, {x:x3,y:y3}, {x:x4,y:y4})
                    && ccw({x:x1,y:y1}, {x:x2,y:y2}, {x:x3,y:y3}) !== ccw({x:x1,y:y1}, {x:x2,y:y2}, {x:x4,y:y4});
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // æ›´å¹³æ»‘çš„ç¼©æ”¾æ§åˆ¶
                const zoomIntensity = 0.002;
                const wheel = e.deltaY < 0 ? 1 : -1;
                const zoomFactor = 1 + wheel * zoomIntensity * Math.abs(this.zoom);
                
                // åº”ç”¨ç¼©æ”¾
                const newZoom = this.zoom * zoomFactor;
                this.zoom = Math.max(0.1, Math.min(5, newZoom));
                
                // è°ƒæ•´å¹³ç§»ä½¿ç¼©æ”¾å›´ç»•é¼ æ ‡ä½ç½®
                this.pan.x = x - (x - this.pan.x) * (this.zoom / newZoom);
                this.pan.y = y - (y - this.pan.y) * (this.zoom / newZoom);
                
                document.getElementById('zoom-level').textContent = Math.round(this.zoom * 100) + '%';
                this.scheduleRender();
            }
            
            handleDrop(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                
                const type = e.dataTransfer.getData('text/plain');
                
                if (type === 'node') {
                    // åˆ›å»ºæ–°èŠ‚ç‚¹
                    const node = new Node(`èŠ‚ç‚¹${this.nodes.length + 1}`, worldPos.x, worldPos.y);
                    this.nodes.push(node);
                    this.addHistory('add-node', node.clone());
                    
                    this.selectedElements = [node];
                    this.updatePropertyPanel();
                    this.scheduleRender();
                }
            }
            
            // å…ƒç´ é€‰æ‹©
            getElementAt(x, y) {
                // å…ˆæ£€æŸ¥è¿çº¿ï¼ˆä»åå¾€å‰ï¼Œå› ä¸ºåé¢çš„è¿çº¿ç»˜åˆ¶åœ¨ä¸Šé¢ï¼‰
                for (let i = this.connections.length - 1; i >= 0; i--) {
                    const connection = this.connections[i];
                    if (this.isPointOnConnection(x, y, connection)) {
                        return connection;
                    }
                }
                
                // æ£€æŸ¥èŠ‚ç‚¹ï¼ˆä»åå¾€å‰ï¼Œå› ä¸ºåé¢çš„èŠ‚ç‚¹ç»˜åˆ¶åœ¨ä¸Šé¢ï¼‰
                for (let i = this.nodes.length - 1; i >= 0; i--) {
                    const node = this.nodes[i];
                    if (this.isPointInNode(x, y, node)) {
                        return node;
                    }
                }
                
                return null;
            }
            
            isPointInNode(x, y, node) {
                return x >= node.x && x <= node.x + node.width && 
                       y >= node.y && y <= node.y + node.height;
            }
            
            isPointOnConnection(x, y, connection) {
                const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                
                if (!sourceNode || !targetNode) return false;
                
                const startX = sourceNode.x + sourceNode.width / 2;
                const startY = sourceNode.y + sourceNode.height / 2;
                const endX = targetNode.x + targetNode.width / 2;
                const endY = targetNode.y + targetNode.height / 2;
                
                const threshold = 5;
                const A = x - startX;
                const B = y - startY;
                const C = endX - startX;
                const D = endY - startY;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) {
                    param = dot / lenSq;
                }
                
                let xx, yy;
                
                if (param < 0) {
                    xx = startX;
                    yy = startY;
                } else if (param > 1) {
                    xx = endX;
                    yy = endY;
                } else {
                    xx = startX + param * C;
                    yy = startY + param * D;
                }
                
                const dx = x - xx;
                const dy = y - yy;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance <= threshold;
            }
            
            // æ¸²æŸ“
            render() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // æ¸…é™¤ç”»å¸ƒ
                ctx.fillStyle = document.body.classList.contains('light-mode') ? '#f5f5f5' : '#1e1e1e';
                ctx.fillRect(0, 0, width, height);
                
                // åº”ç”¨ç¼©æ”¾å’Œå¹³ç§»
                ctx.save();
                ctx.translate(this.pan.x, this.pan.y);
                ctx.scale(this.zoom, this.zoom);
                
                // ç»˜åˆ¶ç½‘æ ¼
                this.drawGrid();
                
                // ç»˜åˆ¶è¿çº¿
                this.connections.forEach(connection => {
                    const isSelected = this.selectedElements.some(el => el.id === connection.id);
                    this.drawConnection(connection, isSelected);
                });
                
                // ç»˜åˆ¶è¿çº¿é¢„è§ˆ
                if (this.creatingConnection) {
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = '#007acc';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const start = this.worldToScreen(
                        this.creatingConnection.x1, 
                        this.creatingConnection.y1
                    );
                    const end = this.worldToScreen(
                        this.creatingConnection.x2, 
                        this.creatingConnection.y2
                    );
                    
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // ç»˜åˆ¶èŠ‚ç‚¹
                this.nodes.forEach(node => {
                    const isSelected = this.selectedElements.some(el => el.id === node.id);
                    this.drawNode(node, isSelected);
                });
                
                ctx.restore();
            }
            
            drawGrid() {
                const ctx = this.ctx;
                const canvasWidth = this.canvas.width;
                const canvasHeight = this.canvas.height;
                const gridSize = 20; // ç½‘æ ¼å¤§å°ï¼Œä¸–ç•Œå•ä½

                // è®¡ç®—å¯è§åŒºåŸŸï¼ˆä¸–ç•Œåæ ‡ï¼‰ï¼Œå¢åŠ ç¼“å†²åŒºé¿å…è¾¹ç¼˜ç©ºç™½
                const visibleLeft = -this.pan.x / this.zoom - gridSize * 2;
                const visibleTop = -this.pan.y / this.zoom - gridSize * 2;
                const visibleRight = (canvasWidth - this.pan.x) / this.zoom + gridSize * 2;
                const visibleBottom = (canvasHeight - this.pan.y) / this.zoom + gridSize * 2;

                // è®¡ç®—ç½‘æ ¼çº¿èµ·å§‹ç‚¹ï¼ˆå¯¹é½åˆ°ç½‘æ ¼ï¼‰
                const startX = Math.floor(visibleLeft / gridSize) * gridSize;
                const endX = Math.ceil(visibleRight / gridSize) * gridSize;
                const startY = Math.floor(visibleTop / gridSize) * gridSize;
                const endY = Math.ceil(visibleBottom / gridSize) * gridSize;

                // è®¾ç½®ç½‘æ ¼æ ·å¼
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--grid').trim() || '#252525';
                ctx.lineWidth = 1 / this.zoom;

                // ç»˜åˆ¶å‚ç›´çº¿
                ctx.beginPath();
                for (let x = startX; x <= endX; x += gridSize) {
                    const screenX = x;
                    ctx.moveTo(screenX, visibleTop);
                    ctx.lineTo(screenX, visibleBottom);
                }
                ctx.stroke();

                // ç»˜åˆ¶æ°´å¹³çº¿
                ctx.beginPath();
                for (let y = startY; y <= endY; y += gridSize) {
                    const screenY = y;
                    ctx.moveTo(visibleLeft, screenY);
                    ctx.lineTo(visibleRight, screenY);
                }
                ctx.stroke();
            }
            
            drawNode(node, isSelected, ctx = this.ctx) {
                // å¦‚æœå¯ç”¨è‡ªé€‚åº”ï¼Œè®¡ç®—åˆé€‚å°ºå¯¸
                if (node.autoSize) {
                    node.calculateAutoSize(ctx);
                }
                
                // èŠ‚ç‚¹èƒŒæ™¯
                const isLightMode = document.body.classList.contains('light-mode');
                ctx.fillStyle = isSelected ? '#2a7fb6' : (isLightMode ? '#ffffff' : '#323233');
                
                // èŠ‚ç‚¹é˜´å½±
                if (isLightMode) {
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                }
                
                ctx.fillRect(node.x, node.y, node.width, node.height);
                
                // æ¸…é™¤é˜´å½±
                if (isLightMode) {
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }
                
                // èŠ‚ç‚¹è¾¹æ¡†
                ctx.strokeStyle = isSelected ? '#007acc' : (isLightMode ? '#dddddd' : '#464647');
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.strokeRect(node.x, node.y, node.width, node.height);
                
                // èŠ‚ç‚¹æ–‡æœ¬
                ctx.fillStyle = isLightMode ? '#333333' : '#e0e0e0';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // åç§°æ–‡æœ¬
                const nameY = node.y + node.height / 2;
                ctx.fillText(node.name, node.x + node.width / 2, nameY);
                
                // æè¿°æ–‡æœ¬ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (node.description) {
                    ctx.font = '10px Arial';
                    ctx.fillStyle = isLightMode ? '#666666' : '#969696';
                    const desc = node.description.length > 30 ? 
                        node.description.substring(0, 30) + '...' : node.description;
                    ctx.fillText(desc, node.x + node.width / 2, nameY + 15);
                }
                
                // æ˜¾ç¤ºå°ºå¯¸ä¿¡æ¯ï¼ˆè°ƒè¯•ç”¨ï¼‰
                if (isSelected) {
                    ctx.font = '8px Arial';
                    ctx.fillStyle = isLightMode ? '#999999' : '#888888';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${node.width}Ã—${node.height}`, node.x + 5, node.y + node.height - 5);
                    ctx.textAlign = 'center';
                }
            }
            
            drawConnection(connection, isSelected, ctx = this.ctx) {
                const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                
                if (!sourceNode || !targetNode) return;
                
                const startX = sourceNode.x + sourceNode.width / 2;
                const startY = sourceNode.y + sourceNode.height / 2;
                const endX = targetNode.x + targetNode.width / 2;
                const endY = targetNode.y + targetNode.height / 2;
                
                // è¿çº¿é¢œè‰²
                const isLightMode = document.body.classList.contains('light-mode');
                ctx.strokeStyle = isSelected ? '#007acc' : (isLightMode ? '#888888' : '#666666');
                ctx.lineWidth = isSelected ? 3 : 2;
                
                // ç»˜åˆ¶è¿çº¿
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // ç»˜åˆ¶ç®­å¤´
                const angle = Math.atan2(endY - startY, endX - startX);
                const arrowLength = 10;
                
                ctx.fillStyle = isSelected ? '#007acc' : (isLightMode ? '#888888' : '#666666');
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle - Math.PI / 6),
                    endY - arrowLength * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle + Math.PI / 6),
                    endY - arrowLength * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
                
                // ç»˜åˆ¶æ¡ä»¶æ•°é‡æ ‡è®°
                if (connection.conditions.length > 0) {
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;
                    
                    ctx.fillStyle = isSelected ? '#007acc' : (isLightMode ? '#aaaaaa' : '#464647');
                    ctx.beginPath();
                    ctx.arc(midX, midY, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = isLightMode ? '#333333' : '#e0e0e0';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(connection.conditions.length.toString(), midX, midY);
                }
            }
            
            // æ›´æ–°å±æ€§é¢æ¿
            updatePropertyPanel() {
                const nodeProperties = document.getElementById('node-properties');
                const connectionProperties = document.getElementById('connection-properties');
                const noSelection = document.getElementById('no-selection');
                
                // åªå¤„ç†å•ä¸ªé€‰æ‹©çš„æƒ…å†µ
                if (this.selectedElements.length === 1) {
                    const element = this.selectedElements[0];
                    
                    if (element.type === 'node') {
                        nodeProperties.classList.remove('hidden');
                        connectionProperties.classList.add('hidden');
                        noSelection.classList.add('hidden');
                        
                        // å¡«å……èŠ‚ç‚¹å±æ€§
                        document.getElementById('node-name').value = element.name;
                        document.getElementById('node-description').value = element.description;
                        document.getElementById('node-width').value = element.width;
                        document.getElementById('node-height').value = element.height;
                        document.getElementById('node-autosize').checked = element.autoSize;
                    } else if (element.type === 'connection') {
                        nodeProperties.classList.add('hidden');
                        connectionProperties.classList.remove('hidden');
                        noSelection.classList.add('hidden');
                        
                        // å¡«å……è¿çº¿æ¡ä»¶
                        this.renderConditions(element);
                    }
                } else {
                    nodeProperties.classList.add('hidden');
                    connectionProperties.classList.add('hidden');
                    noSelection.classList.remove('hidden');
                }
            }
            
            // æ¸²æŸ“è¿çº¿æ¡ä»¶
            renderConditions(connection) {
                const conditionsList = document.getElementById('conditions-list');
                conditionsList.innerHTML = '';
                
                connection.conditions.forEach((condition, index) => {
                    const conditionItem = document.createElement('div');
                    conditionItem.className = 'condition-item';
                    
                    conditionItem.innerHTML = `
                        <div class="condition-header">
                            <span>æ¡ä»¶ ${index + 1}</span>
                            <div class="condition-controls">
                                <button class="move-up" data-index="${index}">â†‘</button>
                                <button class="move-down" data-index="${index}">â†“</button>
                                <button class="delete-condition" data-index="${index}">Ã—</button>
                            </div>
                        </div>
                        <div class="condition-fields">
                            <select class="condition-type" data-index="${index}">
                                <option value="int" ${condition.type === 'int' ? 'selected' : ''}>æ•´æ•°</option>
                                <option value="string" ${condition.type === 'string' ? 'selected' : ''}>å­—ç¬¦ä¸²</option>
                                <option value="bool" ${condition.type === 'bool' ? 'selected' : ''}>å¸ƒå°”å€¼</option>
                                <option value="float" ${condition.type === 'float' ? 'selected' : ''}>æµ®ç‚¹æ•°</option>
                            </select>
                            <input type="text" class="condition-key" data-index="${index}" placeholder="é”®" value="${condition.key}">
                            <div class="condition-operator-value">
                                <select class="condition-operator" data-index="${index}">
                                    <option value="==" ${condition.operator === '==' ? 'selected' : ''}>==</option>
                                    <option value="!=" ${condition.operator === '!=' ? 'selected' : ''}>!=</option>
                                    ${condition.type !== 'string' && condition.type !== 'bool' ? `
                                        <option value=">" ${condition.operator === '>' ? 'selected' : ''}>></option>
                                        <option value="<" ${condition.operator === '<' ? 'selected' : ''}><</option>
                                        <option value=">=" ${condition.operator === '>=' ? 'selected' : ''}>>=</option>
                                        <option value="<=" ${condition.operator === '<=' ? 'selected' : ''}><=</option>
                                    ` : ''}
                                </select>
                                <input type="${condition.type === 'bool' ? 'checkbox' : 'text'}" 
                                       class="condition-value" 
                                       data-index="${index}" 
                                       ${condition.type === 'bool' ? (condition.value === 'true' ? 'checked' : '') : `value="${condition.value}"`}>
                            </div>
                        </div>
                    `;
                    
                    conditionsList.appendChild(conditionItem);
                });
                
                // æ·»åŠ æ¡ä»¶äº‹ä»¶ç›‘å¬
                document.querySelectorAll('.delete-condition').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        connection.conditions.splice(index, 1);
                        this.renderConditions(connection);
                    });
                });
                
                document.querySelectorAll('.move-up').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        if (index > 0) {
                            [connection.conditions[index - 1], connection.conditions[index]] = 
                            [connection.conditions[index], connection.conditions[index - 1]];
                            this.renderConditions(connection);
                        }
                    });
                });
                
                document.querySelectorAll('.move-down').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        if (index < connection.conditions.length - 1) {
                            [connection.conditions[index + 1], connection.conditions[index]] = 
                            [connection.conditions[index], connection.conditions[index + 1]];
                            this.renderConditions(connection);
                        }
                    });
                });
                
                document.querySelectorAll('.condition-type').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        connection.conditions[index].type = e.target.value;
                        this.renderConditions(connection);
                    });
                });
                
                document.querySelectorAll('.condition-key').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        connection.conditions[index].key = e.target.value;
                    });
                });
                
                document.querySelectorAll('.condition-operator').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        connection.conditions[index].operator = e.target.value;
                    });
                });
                
                document.querySelectorAll('.condition-value').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        connection.conditions[index].value = e.target.type === 'checkbox' 
                            ? e.target.checked.toString() 
                            : e.target.value;
                    });
                });
            }
            
            // æ·»åŠ æ¡ä»¶
            addCondition() {
                if (this.selectedElements.length === 1 && this.selectedElements[0].type === 'connection') {
                    const connection = this.selectedElements[0];
                    connection.conditions.push(new Condition());
                    this.renderConditions(connection);
                }
            }
            
            // æ›´æ–°é€‰ä¸­çš„èŠ‚ç‚¹
            updateSelectedNode() {
                if (this.selectedElements.length === 1 && this.selectedElements[0].type === 'node') {
                    const node = this.selectedElements[0];
                    const oldValue = node.clone();
                    
                    node.name = document.getElementById('node-name').value;
                    node.description = document.getElementById('node-description').value;
                    node.width = parseInt(document.getElementById('node-width').value);
                    node.height = parseInt(document.getElementById('node-height').value);
                    node.autoSize = document.getElementById('node-autosize').checked;
                    
                    // å¦‚æœå¯ç”¨äº†è‡ªé€‚åº”ï¼Œé‡æ–°è®¡ç®—å°ºå¯¸
                    if (node.autoSize) {
                        node.calculateAutoSize(this.ctx);
                    }
                    
                    // è®°å½•å†å²
                    this.addHistory('modify-node', {
                        id: node.id,
                        oldValue: oldValue,
                        newValue: node.clone()
                    });
                    
                    this.scheduleRender();
                }
            }
            
            // åˆ‡æ¢è‡ªé€‚åº”å°ºå¯¸
            toggleAutoSize(enabled) {
                if (this.selectedElements.length === 1 && this.selectedElements[0].type === 'node') {
                    const node = this.selectedElements[0];
                    const oldAutoSize = node.autoSize;
                    const oldWidth = node.width;
                    const oldHeight = node.height;
                    
                    node.autoSize = enabled;
                    
                    // å¦‚æœå¯ç”¨äº†è‡ªé€‚åº”ï¼Œé‡æ–°è®¡ç®—å°ºå¯¸
                    if (enabled) {
                        node.calculateAutoSize(this.ctx);
                    }
                    
                    // æ›´æ–°è¾“å…¥æ¡†çŠ¶æ€
                    document.getElementById('node-width').disabled = enabled;
                    document.getElementById('node-height').disabled = enabled;
                    
                    // è®°å½•å†å²
                    this.addHistory('modify-node', {
                        id: node.id,
                        oldValue: { autoSize: oldAutoSize, width: oldWidth, height: oldHeight },
                        newValue: { autoSize: node.autoSize, width: node.width, height: node.height }
                    });
                    
                    this.scheduleRender();
                }
            }
            
            // åˆ é™¤é€‰ä¸­çš„èŠ‚ç‚¹
            deleteSelectedNodes() {
                const nodesToDelete = this.selectedElements.filter(el => el.type === 'node');
                if (nodesToDelete.length > 0) {
                    // æ‰¾åˆ°ç›¸å…³çš„è¿çº¿
                    const nodeIds = nodesToDelete.map(n => n.id);
                    const connectionsToDelete = this.connections.filter(conn => 
                        nodeIds.includes(conn.sourceNodeId) || nodeIds.includes(conn.targetNodeId)
                    );
                    
                    // è®°å½•å†å²
                    this.addHistory('delete-nodes', {
                        nodes: nodesToDelete.map(n => n.clone()),
                        connections: connectionsToDelete.map(c => c.clone())
                    });
                    
                    // æ‰§è¡Œåˆ é™¤
                    this.nodes = this.nodes.filter(n => !nodeIds.includes(n.id));
                    this.connections = this.connections.filter(conn => 
                        !nodeIds.includes(conn.sourceNodeId) && !nodeIds.includes(conn.targetNodeId)
                    );
                    
                    this.selectedElements = [];
                    this.updatePropertyPanel();
                    this.scheduleRender();
                }
            }
            
            // åˆ é™¤é€‰ä¸­çš„è¿çº¿
            deleteSelectedConnections() {
                const connectionsToDelete = this.selectedElements.filter(el => el.type === 'connection');
                if (connectionsToDelete.length > 0) {
                    // è®°å½•å†å²
                    this.addHistory('delete-connections', connectionsToDelete.map(c => c.clone()));
                    
                    // æ‰§è¡Œåˆ é™¤
                    const connIds = connectionsToDelete.map(c => c.id);
                    this.connections = this.connections.filter(c => !connIds.includes(c.id));
                    
                    this.selectedElements = [];
                    this.updatePropertyPanel();
                    this.scheduleRender();
                }
            }
            
            // æ–°å»ºé¡¹ç›®
            newProject() {
                if (confirm('ç¡®å®šè¦æ–°å»ºé¡¹ç›®å—ï¼Ÿå½“å‰é¡¹ç›®çš„æ›´æ”¹å°†ä¼šä¸¢å¤±ã€‚')) {
                    this.nodes = [];
                    this.connections = [];
                    this.selectedElements = [];
                    this.history = [];
                    this.historyIndex = -1;
                    this.updatePropertyPanel();
                    this.scheduleRender();
                }
            }
            
            // å¯¼å‡ºä¸ºMarkdown
            exportMarkdown() {
                let markdown = '# èŠ‚ç‚¹å›¾å¯¼å‡º\n\n';
                
                // å¯¼å‡ºèŠ‚ç‚¹
                markdown += '## èŠ‚ç‚¹åˆ—è¡¨\n';
                this.nodes.forEach(node => {
                    markdown += `- **${node.name}**: ${node.description || 'æ— æè¿°'}\n`;
                });
                
                // å¯¼å‡ºè¿çº¿
                markdown += '\n## è¿çº¿å…³ç³»\n';
                this.connections.forEach(connection => {
                    const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                    const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                    
                    if (sourceNode && targetNode) {
                        markdown += `- ${sourceNode.name} â†’ ${targetNode.name}`;
                        
                        if (connection.conditions.length > 0) {
                            markdown += 'ï¼ˆæ¡ä»¶ï¼š';
                            connection.conditions.forEach((cond, index) => {
                                markdown += `${cond.key} ${cond.operator} ${cond.value}`;
                                if (index < connection.conditions.length - 1) {
                                    markdown += 'ï¼Œ';
                                }
                            });
                            markdown += 'ï¼‰';
                        }
                        
                        markdown += '\n';
                    }
                });
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'èŠ‚ç‚¹å›¾_' + new Date().toISOString().slice(0,10) + '.md';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // ä¿å­˜é¡¹ç›®
            saveProject() {
                const data = {
                    nodes: this.nodes,
                    connections: this.connections
                };
                
                const json = JSON.stringify(data);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'èŠ‚ç‚¹å›¾é¡¹ç›®_' + new Date().toISOString().slice(0,10) + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // å¤„ç†æ–‡ä»¶é€‰æ‹©
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        if (data.nodes && data.connections) {
                            this.nodes = data.nodes.map(n => {
                                const node = new Node(n.name, n.x, n.y);
                                Object.assign(node, n);
                                return node;
                            });
                            
                            this.connections = data.connections.map(c => {
                                const connection = new Connection(c.sourceNodeId, c.targetNodeId);
                                connection.id = c.id;
                                connection.conditions = c.conditions.map(cond => 
                                    new Condition(cond.type, cond.key, cond.operator, cond.value)
                                );
                                return connection;
                            });
                            
                            this.selectedElements = [];
                            this.history = [];
                            this.historyIndex = -1;
                            this.updatePropertyPanel();
                            this.scheduleRender();
                            
                            alert('é¡¹ç›®å¯¼å…¥æˆåŠŸ');
                        } else {
                            alert('æ— æ•ˆçš„é¡¹ç›®æ–‡ä»¶');
                        }
                    } catch (error) {
                        alert('è§£ææ–‡ä»¶æ—¶å‡ºé”™: ' + error.message);
                    }
                };
                reader.readAsText(file);
                
                // é‡ç½®æ–‡ä»¶è¾“å…¥ï¼Œä»¥ä¾¿å¯ä»¥é‡å¤é€‰æ‹©åŒä¸€ä¸ªæ–‡ä»¶
                e.target.value = '';
            }
            
            // 6. æ¢å¤å³é”®èœå•çš„é‡ç½®è§†å›¾åŠŸèƒ½
            showContextMenu(x, y) {
    // åˆ›å»ºæˆ–è·å–ä¸Šä¸‹æ–‡èœå•å…ƒç´ 
    let contextMenu = document.querySelector('.context-menu');
    if (!contextMenu) {
        contextMenu = document.createElement('div');
        contextMenu.className = 'context-menu';
        document.body.appendChild(contextMenu);
    }
    
    // æ¸…ç©ºç°æœ‰èœå•é¡¹
    contextMenu.innerHTML = '';
    
    // æ ¹æ®é€‰ä¸­çš„å…ƒç´ ç±»å‹æ·»åŠ ä¸åŒçš„èœå•é¡¹
    const hasNodes = this.selectedElements.some(el => el.type === 'node');
    const hasConnections = this.selectedElements.some(el => el.type === 'connection');
    
    if (hasNodes) {
        const deleteItem = document.createElement('div');
        deleteItem.className = 'context-menu-item';
        deleteItem.textContent = 'åˆ é™¤èŠ‚ç‚¹';
        deleteItem.addEventListener('click', () => {
            this.deleteSelectedNodes();
            this.hideContextMenu();
        });
        contextMenu.appendChild(deleteItem);
    }
    
    if (hasConnections) {
        const deleteItem = document.createElement('div');
        deleteItem.className = 'context-menu-item';
        deleteItem.textContent = 'åˆ é™¤è¿çº¿';
        deleteItem.addEventListener('click', () => {
            this.deleteSelectedConnections();
            this.hideContextMenu();
        });
        contextMenu.appendChild(deleteItem);
    }
    
    // å¦‚æœæœ‰å¤šä¸ªå…ƒç´ æˆ–æ—¢æœ‰èŠ‚ç‚¹åˆæœ‰è¿çº¿ï¼Œæ·»åŠ åˆ é™¤æ‰€æœ‰çš„é€‰é¡¹
    if (this.selectedElements.length > 1 || (hasNodes && hasConnections)) {
        const deleteAllItem = document.createElement('div');
        deleteAllItem.className = 'context-menu-item';
        deleteAllItem.textContent = 'åˆ é™¤æ‰€æœ‰é€‰ä¸­é¡¹';
        deleteAllItem.addEventListener('click', () => {
            this.deleteSelectedNodes();
            this.deleteSelectedConnections();
            this.hideContextMenu();
        });
        contextMenu.appendChild(deleteAllItem);
    }
    
    // å®šä½èœå• - ä»¥é¼ æ ‡ä½ç½®ä¸ºå·¦ä¸Šè§’
    contextMenu.style.left = x + 'px';
    contextMenu.style.top = y + 'px';
    
    // æ˜¾ç¤ºèœå•
    contextMenu.classList.remove('hidden');
    
    // æ·»åŠ ç‚¹å‡»å…¶ä»–åŒºåŸŸå…³é—­èœå•çš„äº‹ä»¶
    const closeOnClickOutside = (e) => {
        if (!contextMenu.contains(e.target)) {
            this.hideContextMenu();
            document.removeEventListener('click', closeOnClickOutside);
        }
    };
    
    setTimeout(() => {
        document.addEventListener('click', closeOnClickOutside);
    }, 100);
}
// æ·»åŠ éšè—ä¸Šä¸‹æ–‡èœå•çš„æ–¹æ³•
hideContextMenu() {
    const contextMenu = document.querySelector('.context-menu');
    if (contextMenu) {
        contextMenu.classList.add('hidden');
    }
}
            // 7. å®ç°é‡ç½®è§†å›¾åŠŸèƒ½ï¼ˆå°†æ‰€æœ‰èŠ‚ç‚¹å±…ä¸­æ˜¾ç¤ºï¼‰
            resetView() {
                if (this.nodes.length === 0) {
                    // æ²¡æœ‰èŠ‚ç‚¹æ—¶é‡ç½®åˆ°åˆå§‹ä½ç½®
                    this.zoom = 1.0;
                    this.pan.x = 0;
                    this.pan.y = 0;
                    this.scheduleRender();
                    return;
                }
                
                // è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„è¾¹ç•Œæ¡†
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                this.nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x + node.width);
                    maxY = Math.max(maxY, node.y + node.height);
                });
                
                // è®¡ç®—ä¸­å¿ƒç‚¹
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                // è®¡ç®—æ‰€éœ€ç¼©æ”¾æ¯”ä¾‹ä»¥é€‚åº”æ‰€æœ‰èŠ‚ç‚¹
                const canvasWidth = this.canvas.width;
                const canvasHeight = this.canvas.height;
                const contentWidth = maxX - minX;
                const contentHeight = maxY - minY;
                
                const scaleX = canvasWidth / contentWidth * 0.8; // 80% å®½åº¦
                const scaleY = canvasHeight / contentHeight * 0.8; // 80% é«˜åº¦
                const newZoom = Math.min(scaleX, scaleY, 1.0); // æœ€å¤§ä¸è¶…è¿‡100%
                
                // è®¡ç®—æ–°çš„å¹³ç§»ä½ç½®ä½¿èŠ‚ç‚¹å±…ä¸­
                this.zoom = newZoom;
                this.pan.x = canvasWidth / 2 - centerX * newZoom;
                this.pan.y = canvasHeight / 2 - centerY * newZoom;
                
                this.scheduleRender();
            }
            // 8. æ–°å¢å¤„ç†æ¡†é€‰å…ƒç´ çš„å‡½æ•°
            processSelection(minX, minY, maxX, maxY) {
                // é€‰æ‹©èŠ‚ç‚¹
                if (this.selectionFilter === 'all' || this.selectionFilter === 'nodes') {
                    this.nodes.forEach(node => {
                        if (node.x < maxX && node.x + node.width > minX && 
                            node.y < maxY && node.y + node.height > minY) {
                            // æ£€æŸ¥æ˜¯å¦å·²é€‰ä¸­
                            const alreadySelected = this.selectedElements.some(el => el.id === node.id);
                            if (!alreadySelected) {
                                this.selectedElements.push(node);
                            }
                        }
                    });
                }
                
                // é€‰æ‹©è¿çº¿
                if (this.selectionFilter === 'all' || this.selectionFilter === 'connections') {
                    this.connections.forEach(connection => {
                        const sourceNode = this.nodes.find(n => n.id === connection.sourceNodeId);
                        const targetNode = this.nodes.find(n => n.id === connection.targetNodeId);
                        if (!sourceNode || !targetNode) return;
                        
                        const startX = sourceNode.x + sourceNode.width / 2;
                        const startY = sourceNode.y + sourceNode.height / 2;
                        const endX = targetNode.x + targetNode.width / 2;
                        const endY = targetNode.y + targetNode.height / 2;
                        
                        // æ£€æŸ¥è¿çº¿æ˜¯å¦ä¸é€‰æ‹©æ¡†ç›¸äº¤
                        const lineIntersects = this.lineIntersectsRectangle(
                            startX, startY, endX, endY, minX, minY, maxX, maxY
                        );
                        
                        if (lineIntersects) {
                            const alreadySelected = this.selectedElements.some(el => el.id === connection.id);
                            if (!alreadySelected) {
                                this.selectedElements.push(connection);
                            }
                        }
                    });
                }
                
                this.updatePropertyPanel();
            }          
            // ç¼©æ”¾æ§åˆ¶
            zoomIn() {
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const zoomFactor = 1.1;
                const newZoom = this.zoom * zoomFactor;
                this.zoom = Math.min(5, newZoom);
                
                // è°ƒæ•´å¹³ç§»ä½¿ç¼©æ”¾å›´ç»•ä¸­å¿ƒ
                this.pan.x = centerX - (centerX - this.pan.x) * (this.zoom / newZoom);
                this.pan.y = centerY - (centerY - this.pan.y) * (this.zoom / newZoom);
                
                document.getElementById('zoom-level').textContent = Math.round(this.zoom * 100) + '%';
                this.scheduleRender();
            }
            
            zoomOut() {
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const zoomFactor = 0.9;
                const newZoom = this.zoom * zoomFactor;
                this.zoom = Math.max(0.1, newZoom);
                
                // è°ƒæ•´å¹³ç§»ä½¿ç¼©æ”¾å›´ç»•ä¸­å¿ƒ
                this.pan.x = centerX - (centerX - this.pan.x) * (this.zoom / newZoom);
                this.pan.y = centerY - (centerY - this.pan.y) * (this.zoom / newZoom);
                
                document.getElementById('zoom-level').textContent = Math.round(this.zoom * 100) + '%';
                this.scheduleRender();
            }
        }
        
        // åˆå§‹åŒ–ç¼–è¾‘å™¨
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('editor-canvas');
            const editor = new NodeGraphEditor(canvas);
        });
    </script>
</body>
</html>