<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PropertyReflection 简单测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover {
            background: #0056b3;
        }
        .result {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PropertyReflection 简单测试</h1>
        
        <div>
            <button class="test-button" onclick="testSimpleObject()">测试简单对象</button>
            <button class="test-button" onclick="testComplexObject()">测试复杂对象</button>
            <button class="test-button" onclick="clearConsole()">清空控制台</button>
        </div>
        
        <div id="result" class="result"></div>
    </div>

    <script>
        // 简化的PropertyDefinition类
        class PropertyDefinition {
            constructor(propertyName, options = {}) {
                this.name = propertyName;
                this.displayName = options.displayName || this.formatDisplayName(propertyName);
                this.type = options.type || 'string';
                this.editable = options.editable !== false;
                this.readOnly = !!options.readOnly;
                this.visible = options.visible !== false;
                this.description = options.description || '';
                this.group = options.group || 'Default';
                this.defaultValue = options.defaultValue;
                this.order = options.order !== undefined ? options.order : 0;
            }
            
            formatDisplayName(propertyName) {
                return propertyName
                    .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
                    .replace(/^([a-z])/, match => match.toUpperCase());
            }
            
            clone() {
                return new PropertyDefinition(this.name, {
                    displayName: this.displayName,
                    type: this.type,
                    editable: this.editable,
                    readOnly: this.readOnly,
                    visible: this.visible,
                    description: this.description,
                    group: this.group,
                    defaultValue: this.defaultValue,
                    order: this.order
                });
            }
        }

        // 简化的PropertyReflection类
        class PropertyReflection {
            constructor() {
                this.typeMap = new Map();
                this.classDefinitionCache = new Map();
                
                this.registerTypeHandler(Number, this.handleNumberType.bind(this));
                this.registerTypeHandler(String, this.handleStringType.bind(this));
                this.registerTypeHandler(Boolean, this.handleBooleanType.bind(this));
                this.registerTypeHandler(Array, this.handleArrayType.bind(this));
                this.registerTypeHandler(Date, this.handleDateType.bind(this));
            }

            registerTypeHandler(type, handler) {
                this.typeMap.set(type, handler);
            }

            getObjectProperties(object) {
                console.log('PropertyReflection.getObjectProperties called with:', object);
                console.log('对象类型:', typeof object);
                console.log('对象构造函数:', object?.constructor?.name);
                
                if (!object || typeof object !== 'object') {
                    console.log('对象无效或不是对象类型，返回空属性');
                    return {};
                }

                const objectClass = object.constructor;
                if (objectClass !== Object && this.classDefinitionCache.has(objectClass)) {
                    console.log('从缓存获取类定义:', objectClass.name);
                    const cachedDef = this.classDefinitionCache.get(objectClass);
                    const result = {};
                    for (const [key, def] of Object.entries(cachedDef)) {
                        result[key] = def.clone();
                    }
                    console.log('返回缓存的属性定义:', result);
                    return result;
                }

                const properties = {};
                const ownProps = Object.getOwnPropertyNames(object);
                let proto = Object.getPrototypeOf(object);
                const protoProps = new Set();
                
                while (proto && proto !== Object.prototype) {
                    const props = Object.getOwnPropertyNames(proto);
                    props.forEach(prop => {
                        if (prop !== 'constructor' && typeof proto[prop] !== 'function') {
                            protoProps.add(prop);
                        }
                    });
                    proto = Object.getPrototypeOf(proto);
                }

                const allProps = new Set([...ownProps, ...protoProps]);
                
                if (typeof object.getPropertyDefinitions === 'function') {
                    const customDefs = object.getPropertyDefinitions();
                    for (const [key, def] of Object.entries(customDefs)) {
                        allProps.add(key);
                        properties[key] = def;
                    }
                }

                allProps.forEach(propName => {
                    if (properties[propName]) return;
                    if (propName.startsWith('_')) return;
                    if (typeof object[propName] === 'function') return;
                    
                    const descriptor = Object.getOwnPropertyDescriptor(object, propName);
                    if (descriptor && !descriptor.enumerable) return;
                    
                    const propertyDef = this.createPropertyDefinition(propName, object[propName]);
                    
                    if (descriptor) {
                        if (!descriptor.writable && !descriptor.set) {
                            propertyDef.readOnly = true;
                        }
                    }
                    
                    properties[propName] = propertyDef;
                });

                if (objectClass !== Object) {
                    this.classDefinitionCache.set(objectClass, properties);
                }

                return properties;
            }

            createPropertyDefinition(propertyName, propertyValue) {
                const type = this.determineType(propertyValue);
                const options = { type: type };
                
                const typeHandler = this.getTypeHandler(type);
                if (typeHandler) {
                    typeHandler(options, propertyValue);
                }
                
                return new PropertyDefinition(propertyName, options);
            }

            determineType(value) {
                if (value === null) return 'string';
                
                const type = typeof value;
                
                if (type === 'object') {
                    if (Array.isArray(value)) return 'array';
                    if (value instanceof Date) return 'date';
                    if (value.constructor && value.constructor !== Object) {
                        const className = value.constructor.name || 'object';
                        return className.toLowerCase();
                    }
                    return 'object';
                }
                
                return type;
            }

            getTypeHandler(type) {
                for (const [handlerType, handler] of this.typeMap.entries()) {
                    if (type === handlerType.name.toLowerCase()) {
                        return handler;
                    }
                }
                
                return this.handleDefaultType.bind(this);
            }

            handleNumberType(options, value) {
                options.min = -Infinity;
                options.max = Infinity;
                options.step = Number.isInteger(value) ? 1 : 0.1;
            }

            handleStringType(options, value) {
                options.maxLength = null;
                options.multiline = false;
                
                if (value && value.length > 50) {
                    options.multiline = true;
                }
            }

            handleBooleanType(options, value) {
                // 布尔类型不需要特殊处理
            }

            handleArrayType(options, value) {
                options.itemType = 'string';
            }

            handleDateType(options, value) {
                // 日期类型不需要特殊处理
            }

            handleDefaultType(options, value) {
                // 默认处理
            }

            getSortedProperties(properties) {
                const entries = Object.entries(properties);
                entries.sort((a, b) => {
                    const orderA = a[1].order || 0;
                    const orderB = b[1].order || 0;
                    return orderA - orderB;
                });
                return Object.fromEntries(entries);
            }
        }

        // 创建实例
        const propertyReflection = new PropertyReflection();

        function testSimpleObject() {
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = '';
            resultDiv.className = 'result';
            
            try {
                const simpleObj = {
                    name: '测试节点',
                    x: 100,
                    y: 200,
                    width: 120,
                    height: 60,
                    visible: true,
                    color: '#ff6b6b'
                };
                
                console.log('测试简单对象:', simpleObj);
                const properties = propertyReflection.getObjectProperties(simpleObj);
                
                console.log('获取到的属性:', properties);
                
                const result = {
                    input: simpleObj,
                    properties: properties,
                    propertyCount: Object.keys(properties).length
                };
                
                resultDiv.textContent = JSON.stringify(result, null, 2);
                resultDiv.className = 'result success';
                
            } catch (error) {
                console.error('测试简单对象失败:', error);
                resultDiv.textContent = '错误: ' + error.message;
                resultDiv.className = 'result error';
            }
        }

        function testComplexObject() {
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = '';
            resultDiv.className = 'result';
            
            try {
                const complexObj = {
                    id: 'node_123',
                    name: '复杂节点',
                    position: { x: 100, y: 200 },
                    size: { width: 120, height: 60 },
                    style: {
                        color: '#ff6b6b',
                        borderColor: '#333',
                        borderWidth: 2
                    },
                    tags: ['important', 'test'],
                    metadata: {
                        created: new Date(),
                        author: 'test'
                    },
                    visible: true,
                    locked: false,
                    customProperty: '自定义值',
                    numberProperty: 42.5,
                    booleanProperty: true,
                    arrayProperty: [1, 2, 3],
                    nullProperty: null,
                    undefinedProperty: undefined
                };
                
                console.log('测试复杂对象:', complexObj);
                const properties = propertyReflection.getObjectProperties(complexObj);
                
                console.log('获取到的属性:', properties);
                
                const result = {
                    input: complexObj,
                    properties: properties,
                    propertyCount: Object.keys(properties).length
                };
                
                resultDiv.textContent = JSON.stringify(result, null, 2);
                resultDiv.className = 'result success';
                
            } catch (error) {
                console.error('测试复杂对象失败:', error);
                resultDiv.textContent = '错误: ' + error.message;
                resultDiv.className = 'result error';
            }
        }

        function clearConsole() {
            console.clear();
            document.getElementById('result').textContent = '';
        }

        // 页面加载完成后自动运行第一个测试
        window.addEventListener('load', function() {
            setTimeout(() => {
                testSimpleObject();
            }, 1000);
        });
    </script>
</body>
</html>